# 쉽게 배우는 운영체제 Ch.4

## Table of Contents

1. [스케줄링의 개요](#1.-스케줄링의-개요)
2. [스케줄링의 단계](#2.-스케줄링의-단계)
3. [스케줄링의 목적](#3.-스케줄링의-목적)
4. [스케줄링 알고리즘](#4.-스케줄링-알고리즘)

## 1. 스케줄링의 개요
CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 한다. CPU 스케줄러는 프로세서 스케줄러<sup>processor scheduler</sup>라고도 한다.

스케줄링은 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다.

### 2. 스케줄링의 단계
CPU 스케줄러는 관리의 범주를 나누어 스케줄링을 한다. CPU 스케줄링은 규모에 따라 고수준 스케줄링, 중산 수준 스케줄링, 저수준 스케줄링으로 구분된다.

#### 2.1 고수준 스케줄링
가장 큰 틀에서 이루어지는 CPU 스케줄링을 고수준 스케줄링<sup>high level scheduling</sup> 또는 장기 스케줄링<sup>long-term scheduling</sup>, 작업 스케줄링<sup>job scheduling</sup>이라고 한다. 많은 작업을 동시에 하면 시스템에 과부하가 걸려 작업이 원활하게 이루어지지 않는다.

고수준 스케줄링은 시스템 내의 전체 작업 수를 조절하는 것을 말한다. 여기서 작업은 운영체제에서 다루는 일의 가장 큰 단위로, 1개 또는 여러 개의 프로세스로 이루어진다. 고수준 스케줄링 단계에서는 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정한다. 일단 작업이 시작되면 시스템 자원을 사용하기 때문에 기존 작업에 영향을 미친다. 작업 요청이 오면 스케줄러가 시스템의 상황을 고려하여 작업을 승인할지, 거부할지를 결정하므로 고수준 스케줄링을 승인 스케줄링<sup>addmission scheduling</sup>이라고도 한다. 고수준 스케줄링에 따라 시스템 내에서 동시에 실행 가능한 프로세스의 총개수가 정해진다.

#### 2.2 저수준 스케줄링
고수준 스케줄링과 반대로 가장 작은 단위의 스케줄링을 저수준 스케줄링<sup>low level scheduling</sup>이라고 한다.

CPU 스케줄러 입장에서 저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 일이다. 준비 상태에 있는 프로세스 중 하나를 골라 실행 상태로 보내고, 실행 상태에 있는 프로세스를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보내는 것을 예로 들 수 있다. 저수준 스케줄링은 아주 짧은 시간에 일어나기 때문에 단기 스케줄링<sup>short-term scheduling</sup>이라고 부른다.

#### 2.3 중간수준 스케줄링
중간 수준 스케줄링<sup>middle level scheduling</sup>은 고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링이다.

중간 수준 스케줄링은 중지<sup>suspend</sup>와 활성화<sup>active</sup>로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다. 즉 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원한다. 이는 프로세스의 상태 중 보류 상태에 해당하며, 저수준 스케줄링이 원만하게 이루어지도록 완충하는<sup>buffer</sup> 역할을 한다.

#### 2.4 스케줄링의 단계 정리
- **고수준 스케줄링**  
고수준 스케줄링에서는 전체 시스템의 부하를 고려하여 작업을 시작할지 말지를 결정한다. 이 결정에 따라 시스템의 전체 프로세스 수가 결정되는데 이를 멀티프로그래밍 정도<sup>degree of multiprogramming</sup>라고 한다. 고수준 스케줄링은 메인프레임과 같은 큰 시스템에서 규모가 큰 일괄 작업을 처리할 때 사용된다.
- **중간 수준 스케줄링**  
시스템의 부하를 조절하려면 고수준 스케줄링 대신 중간 수준 스케줄링을 고려해야 한다. 시스템에 과부하가 걸려서 전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 보류 상태로 보낸다. 보류된 프로세스는 처리 능력에 여유가 생기면 다시 활성화된다.
- **저수준 스케줄링**  
저수준 스케줄링에서는 실제로 작업이 이루어진다. 오늘날의 CPU 스케줄러는 대부분 중간 수준 스케줄링과 저수준 스케줄링으로 구성되어 있다. CPU 스케줄러는 필요에 따라 준비 상태에 있는 프로세스를 실행 상태로 옮기기도 하고, 대기 상태로 보내기도 하며, 타임아웃으로 준비 상태로 돌려보내기도 한다. 준비 상태에 있는 프로세스 중 어떤 프로세스를 선택할지, 어떤 기준에 따라 타임 슬라이스를 정할지 등은 시스템의 성능에 많은 영향을 미친다.

### 3. 스케줄링의 목적
- **공평성**: 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
- **효율성**: 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
- **안정성**: 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호해야 한다.
- **확장성**: 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
- **반응 시간 보장**: 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- **무한 연기 방지**: 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

## 2. 스케줄링 시 고려 사항

### 1. 선점형 스케줄링과 비선점형 스케줄링
- **선점형 스케줄링<sup>preemptive scheduling</sup>**  
어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- **비선점형 스케줄링<sup>non-preemptive scheduling</sup>**  
어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식


| 구분 | 선점형 | 비선점형 |
| --- | ---- | ------ |
| 작업 방식 | 실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있음 | 실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능 |
| 장점 | 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합함 | CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적음 |
| 단점 | 문맥 교환의 오버헤드가 많음 | 기다리는 프로세스가 많아 처리율이 떨어짐 |
| 사용 | 시분할 방식 스케줄러에 사용 | 일괄 작업 방식 스케줄러에 사용 |
| 중요도 | 높음 | 낮음 |

### 2. 프로세스 우선순위
대부분의 CPU 스케줄러는 우선순위를 사용한다. 우선순위가 있다는 것은 프로세스의 중요도가 다르다는 의미이다.

프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉜다. CPU 스케줄러는 각 프로세스에 우선순위를 부여하는데 커널 프로세스의 우선순위가 일반 프로세스보다 높다. 우선순위가 높다는 것은 더 빨리 자주 실행된다는 의미이다.

### 3. CPU 집중 프로세스와 입출력 집중 프로세스
- **CPU 집중 프로세스**: 수학 연산과 같이 CPU를 많이 사용하는 프로세스를 말한다. 즉 CPU 버스트가 많은 프로세스이다.
- **입출력 집중 프로세스**: 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스를 말한다. 즉 입출력 버스트가 많은 프로세스이다.

CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있을 때는 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.

스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템의 효율이 향상된다. 입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기<sup>cycle stealing</sup>라고 한다.

### 4. 전면 프로세스와 후면 프로세스
- **전면 프로세스**: GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스를 말한다. 현재 입력과 출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능하여 상호작용 프로세스라고 한다.
- **후면 프로세스**: 사용자와 상호작용이 없는 프로세스이다. 압축 프로그램처럼 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 한다.

### 5. 정리
| 우선순위 높음 |   | 우선 순위 낮음 |
| ---------- | - | ---------- |
| 커널 프로세스 | ↔ | 일반 프로세스 |
| 전면 프로세스 | ↔ | 후면 프로세스 |
| 대화형 프로세스 | ↔ | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | ↔ | CPU 집중 프로세스 |

## 3. 다중 큐

### 1. 준비 상태의 다중 큐
- **고정 우선순위 방식**: 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식이다. 프로세스가 작업하는 동안 우선순위가 변하지 않기 때문에 구현하기 쉽지만, 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 시스템의 변화에 대응하기 어려워 작업 효율이 떨어진다.
- **변동 우선순위 방식**: 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식이다. 구현하기 어렵지만 시스템의 효율성을 높일 수 있다.

프로세스의 낮은 우선순위를 높은 우선순위로 바꾸는 것을 반전 우선순위<sup>priority inversion</sup>라고 한다. 변동 우선순위 방식인 반전 우선순위를 사용하면 시스템의 효율성이 향상된다.

### 2. 대기 상태의 다중 큐
대기 상태에서도 다중 큐를 사용한다. 시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓는다.

준비 상태의 다중 큐와 대기 상태의 다중 큐는 차이가 있다. 준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당하는 반면, 대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다. 시스템에는 많은 입출력장치가 있기 때문에 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리한다. 이렇게 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터<sup>interrupt vector</sup>라는 자료 구조를 사용한다.

대기 상태의 다중 큐에 있는 프로세스 제어 블록은 큐에 삽입된 순서대로 처리되지만, 일부는 나중에 들어온 프로세스 제어 블록이 먼저 준비 상태로 옮겨 가기도 한다. 입출력장치는 CPU나 메모리보다 느리기 때문에 작업 속도를 높이기 위해 작업 순서를 뒤바꾸는 경우가 있는데, 이때는 나중에 요청된 작업이 먼저 처리되기도 한다.

## 4. 스케줄링 알고리즘

스케줄링 알고리즘은 크게 비선점형 알고리즘<sup>non-preemptive algorithm</sup>과 선점형 알고리즘<sup>preemptive algorithm</sup>으로 나뉜다. 비선점형 알고리즘은 프로세스가 CPU를 할당받으면 작업이 끝날 때까지 CPU를 놓지 않기 때문에 효율이 떨어져서 지금은 거의 사용되지 않는다. 선점형 알고리즘은 시분할 시스템을 고려하여 만들어진 알고리즘으로, 어떤 프로세스가 CPU를 할당받아 실행 중이라도 운영체제가 CPU를 강제로 빼앗을 수 있다.

**스케줄링 알고리즘의 종류**
| 구분 | 종류 |
| --- | --- |
| 비선점형 알고리즘 | FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링 |
| 선점형 알고리즘 | 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링 | 
| 둘 다 가능 | 우선순위 스케줄링 |

### 1. 스케줄링 알고리즘의 선택 기준
- **CPU 사용률**: 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법이다. 가장 이상적인 수치는 100%이지만 실제로는 여러 가지 이유로 90%에도 못 미친다.
- **처리량**: 시스템이 정상적으로 작동한다면 일정 시간 후 작업이 끝난다. 처리량은 단위 시간당 작업을 마친 프로세스의 수로, 이 수치가 클수록 좋은 알고리즘이다.
- **대기 시간**: 작업을 요청하더라도 실제 작업이 이루어지기 전까지는 대기 시간이 필요하다. 대기 시간은 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간으로, 이 시간이 짧을수록 좋다.
- **응답 시간**: 대화형 시스템에서는 사용자의 요구에 얼마 만에 반응하는지가 중요하다. 응답 시간은 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간으로, 이 시간 역시 짧을수록 좋다.
- **반환 시간**: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간이다. 반환 시간은 대기 시간과 실행 시간을 더한 값이다.

용어 설명
- **대기 시간**: 프로세스가 생성된 후 실행되기 전까지 대기하는 시간
- **응답 시간**: 첫 작업을 시잔한 후 첫 번째 출력(반응)이 나오기까지의 시간
- **실행 시간**: 프로세스 작업이 시작된 후 종료되기까지의 시간
- **반환 시간**: 대기 시간을 포함하여 실행이 종료될 때까지의 시간

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다. 평균 대기 시간은 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값이다.

### 2. FCFS<sup>First Come First Served</sup> 스케줄링
#### 2.1 FCFS 스케줄링의 동작 방식
FCFS 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식으로, 선입선출 스케줄링이다.

초기의 일괄 작업 시스템에서 사용되었던 FCFS 스케줄링은 프로세스가 큐에 도착한 순서대로 실행되며, 비선점형 방식이기 때문에 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있다. 게다가 큐가 하나라 모든 프로세스는 우선순위가 동일하다.

#### 2.3 FCFS 스케줄링의 평가
FCFS 스케줄링 알고리즘은 단순하고 공평하지만, 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제가 있는데 이를 콘보이 효과<sup>convoy effect</sup> 또는 호위 효과라고 한다. 즉 컨베이어 벨트에 작업물이 한 줄로 늘어서 있을 때 앞의 작업이 오래 걸려서 뒤의 작업이 지연되는 현상과 같다.

FCFS 스케줄링의 또 다른 단점은 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어진다는 것이다. 시분할 시스템에서는 입출력을 요청한 프로세스를 대기 상태로 보내어 처리할 수 있지만, 일괄 작업 시스템에서는 프로세스의 상태 변화가 없기 때문에 작업 효율이 떨어진다.

### 3. SJF<sup>Shortest Job First</sup> 스케줄링
#### 3.1 SJF 스케줄링의 동작 방식
SJF 스케줄링은 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식으로, 최단 작업 우선 스케줄링이라고도 한다.

SJF 스케줄링은 프로세스에 CPU를 배정할 때 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 그 순서를 바꾸어 실행한다. FCFS 스케줄링의 콘보이 효과를 완화하여 시스템의 효율성을 높이는 것이다.

SJF 스케줄링은 SPF<sup>Shortest Process First</sup> 또는 최단 프로세스 우선 스케줄링이라고도 한다.

#### 3.3 SJF 스케줄링의 평가
SJF 스케줄링은 작은 작업을 먼저 실행하기 때문에 시스템의 효율성이 좋아진다. 먼저 도착한 큰 작업으로 인해 작은 작업이 지연되는 FCFS 스케줄링보다 평균 대기 시간이 줄어들어 시스템의 효율성이 높아지는 것이다. 그러나 이러한 장점에도 불구하고 SJF 스케줄링은 다음과 같은 이유로 사용하기가 힘들다.

- **운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.**
- **공평하지 못하다.**

### 4. HRN<sup>Highest Response Ratio Next</sup> 스케줄링
#### 4.1 HRN 스케줄링의 동작 방식
HRN 스케줄링은 SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘으로, 최고 응답률 우선 스케줄링이라고도 한다. HRN 스케줄링은 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식이다.

> 우선순위 = 대기 시간 + CPU 사용 시간 / CPU 사용 시간

HRN 스케줄링은 우선순위를 정할 때 대기 시간을 고려함으로써 아사 현상을 완화한다. 즉 스케줄링 방식에 에이징을 구현한 셈이다.

#### 4.2 HRN 스케줄링의 평가
HRN 스케줄링은 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화한다. SJF 스케줄링과 비교하면 대기 시간이 긴 프로세스의 우선순위를 높임으로써 CPU를 할당받을 확률을 높인다. 그러나 여전히 공평성이 위배되어 많이 사용되지 않는다.

### 5. 라운드 로빈<sup>Round Robin, RR</sup> 스케줄링
#### 5.1 라운드 로빈 스케줄링의 동작 방식
'순환 순서 방식'으로 번역되는 라운드 로빈 스케줄링은 한 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.

라운드 로빈 스케줄링은 FCFS 스케줄링과 유사하넫, 차이점은 각 프로세스마다 CPU를 사용할 수 있는 최대 시간, 즉 타임 슬라이스가 있다는 것이다.

라운드 로빈 스케줄링 같은 선점형 방식에서는 프로세스가 CPU를 일정 시간 동안 사용한 후 다른 프로세스에 주어야 하기 때문에 앞의 긴 작업을 무작정 기다리는 콘베이 효과가 줄어든다.

#### 5.3 타임 슬라이스의 크기와 문맥 교환
라운드 로빈 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율적인 알고리즘이다. 라운드 로빈 스케줄링 같은 선점형 방식에서는 문맥 교환 시간이 추가되기 때문이다.

라운드 로빈 스케줄링이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 한다. 타임 슬라이스의 크기는 프로세스의 반응 시간에 영향을 미칠 뿐 아니라 시스템 전체의 성능에도 영향을 미친다.

- **타임 슬라이스가 큰 경우**  
타임 슬라이스가 너무 크면 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것처럼 보인다. 이 경우 FCFS 스케줄링과 다를 게 없는데, 실제로 라운드 로빈 스케줄링에서 타임 슬라이스가 무한대이면 FCFS 스케줄링이 된다.
- **타임 슬라이스가 작은 경우**  
타임 슬라이스를 1밀리초와 같이 매우 작은 값으로 설정하면 사용자는 여러 프로그램이 동시에 실행되는 것처럼 느낄 것이다. 그러나 타임 슬라이스를 너무 작게 설정하면 시스템의 전반적인 성능이 떨어진다. 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생한다.

### 6. SRT<sup>Shortest Remaining Time</sup> 우선 스케줄링
#### 6.1 SRT 스케줄링의 동작 방식
SRT 스케줄링은 SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식으로, 최소 잔류 시간 우선 스케줄링이라고도 한다. SRT 스케줄링은 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택한다.

#### 6.3 SRT 스케줄링의 평가
현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가된다. 또한 SRT 스케줄링은 SJF 스케줄링과 마찬가지로 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않는다.

### 7. 우선순위 스케줄링
#### 7.1 우선순위 스케줄링의 동작 방식
프로세스는 중요도에 따라 우선순위<sup>priority</sup>를 갖는데 이러한 우선순위를 반영한 스케줄링 알고리즘이 우선순위 스케줄링이다.

우선순위 알고리즘은 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉜다.
- **고정 우선순위 알고리즘**: 한 번 우선순위를 부여받으면 종료될 때까지 우선순위가 고정된다. 단순하게 구현할 수 있지만 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어진다.
- **변동 우선순위 알고리즘**: 일정 시간마다 우선순위가 변한다. 일정 시간마다 우선순위를 새로 계산하고 이를 반영하기 때문에 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적인 운영이 가능하다.

#### 7.2 우선순위 스케줄링의 평가
우선순위 스케줄링은 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킨다는 것이 문제이다. 또한 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템의 효율성을 떨어뜨린다.

### 8. 다단계 큐<sup>multilevel queue</sup> 스케줄링
다단계 큐 스케줄링은 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다. 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다. 라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 프로세스가 큐에 삽입되는 것만으로 우선순위가 결정된다. 우선순위는 고정형 우선순위를 사용하며, 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다.

다단계 큐 스케줄링은 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식이다. 우선순위가 높은 프로세스가 우선순위가 낮은 프로세스보다 먼저 작동할 수 있을뿐더러 우선순위에 따라 타임 슬라이스를 조절하여 작업 효율을 높일 수도 있다.

다단계 큐 스케줄링은 우선순위가 높은 상위 큐 프로세스의 작업이 끝나기 전에는 하위 큐 프로세스의 작업을 할 수 없다. 우선순위가 1번인 큐에 CPU 할당을 기다리는 프로세스가 있다면 우선순위가 2번인 큐의 프로세스는 1번 큐에 있는 프로세스의 작업이 끝날 때까지 기다려야 한다. 즉 우선순위가 높은 프로세스 때문에 우선순위가 낮은 프로세스의 작업이 연기되는데, 이러한 문제를 해결하기 위해 제안된 것이 다단계 피드백 큐 스케줄링이다.

### 9. 다단계 피드백 큐<sup>multilevel feedback queue</sup> 스케줄링
다단계 피드백 큐 스케줄링은 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식이다. 다단계 피드백 큐 스케줄링은 다단계 스케줄링과 기본적인 형태가 같아 우선순위를 가진 여러 개의 큐를 사용한다. 하지만 다단계 큐 스케줄링의 경우 각 단계의 큐에 라운드 로빈 방식을 사용하고 우선순위에는 변화가 없는 데 반해, 다단계 피드백 큐 스케줄링의 경우 CPU를 사용하고 난 프로세스의 우선순위가 낮아진다. CPU를 사용하고 난 프로세스는 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.

다단계 피드백 큐 스케줄링은 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다. 물론 프로세스의 우선순위가 낮아진다고 할지라도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않는다.

다다계 피드백 큐 스케줄링의 또 다른 특징은 우선순위에 따라 타임 슬라이스의 크기가 다르다는 것이다. 다단계 피드백 큐 스케줄링은 우선순위가 낮은 프로세스의 실행 기회를 확대하려고 하지만, 그렇다고 해도 우선순위가 낮은 프로세스가 우선순위가 높은 프로세스보다 CPU를 얻을 확률이 여전히 낮다. 따라서 어렵게 얻은 CPU를 좀 더 오랫동안 사용할 수 있도록 우선순위가 낮은 큐의 타임 슬라이스를 크게 설정한다.

다단계 피드백 큐 스케줄링에서 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작한다.

다단계 피드백 큐 스케줄링은 오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용하는 방식으로, 변동 우선순위 알고리즘의 전형적인 예이다.