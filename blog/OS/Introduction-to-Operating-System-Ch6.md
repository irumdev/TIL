# 쉽게 배우는 운영체제 Ch.6

## Table of Contents

1. [교착 상태의 개요](#1.-교착-상태의-개요)
2. [교착 상태 필요조건](#2.-교착-상태-필요조건)
3. [교착 상태 해결 방법](#3.-교착-상태-해결-방법)

# 1. 교착 상태의 개요
## 1. 교착 상태의 정의

2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태를 교착 상태<sup>dead lock</sup>라고 한다.

교착 상태는 아사 현상과 비슷해 보이지만 차이점이 있다. 아사 현상은 운영체제가 잘못된 정책을 사용하여 특정 프로세스의 작업이 지연되는 문제이고, 교착 상태는 여러 프로세스가 작업을 진행하다 보니 자연적으로 일어나는 문제이다. 따라서 운영체제는 감시를 하다가 교착 상태가 발생하면 강압적으로 해결해야 한다.

## 2. 교착 상태의 발생

컴퓨터 시스템에서 교착 상태는 시스템 자원, 공유 변수(또는 파일), 응용 프로그램 등을 사용할 때 발생할 수 있다.

- **시스템 자원**  
교착 상태는 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생한다. 어떤 프로세스가 임계구역으로 보호되는 하드웨어를 동시에 같이 사용할 수 없는 시스템 자원을 할당받은 후 양보하지 않는 경우를 예로 들 수 있다.
- **공유 변수**  
교착 상태는 공유 변수를 사용할 때도 발생한다.
- **응용 프로그램**  
데이터베이스 같은 응용 프로그램에서도 교착 상태가 발생한다. 여러 프로세스가 데이터베이스에 저장된 데이터를 사용할 때는 데이터의 일관성을 유지해야 한다. 데이터베이스는 데이터의 일관성을 유지하기 위해 잠금을 사용하는데, 이때 교착 상태가 발생할 수 있다.

## 3. 자원 할당 그래프
자원 할당 그래프<sup>resource allocation graph</sup>는 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프<sup>directional graph</sup>로 표현한 것이다.

자원이 2개 이상의 프로세스를 동시에 허용하는 경우가 있다. 여러 프로세스가 하나의 자원을 동시에 사용하면 이를 다중 지원<sup>multiple resource</sup>이라고 부른다.

# 2. 교착 상태 필요조건
## 1. 교착 상태 필요조건
교착 상태는 여러 가지 조건에 의해 발생한다. 즉 교착 상태는 상호 배제<sup>mutual exclusion</sup>, 비선점<sup>non-preemption</sup>, 점유와 대기<sup>hold and wait</sup>, 원형 대기<sup>circular wait</sup>를 모두 충족해야 발생한다. 이 중 단 하나라도 충족하지 않으면 교착상태가 발생하지 않는다.

- **상호 배제**: 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다. 배타적인 자원은 임계구역으로 보호되기 때문에 다른 프로세스가 동시에 사용할 수 없다. 따라서 배타적인 자원을 사용하면 교착 상태가 발생한다.
- **비선점**: 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다. 어떤 자원을 빼앗을 수 있다면 시간 간격을 두고 자원을 공유할 수 있다. 하지만 자원을 빼앗을 수 없으면 공유할 수도 없으므로 교착 상태가 발생한다.
- **점유와 대기**: 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 한다. 다른 프로세스의 작업 진행을 방해하는 교착 상태가 발생하려면 다른 프로세스가 필요로 하는 자원을 점유하고 있으면서 또 다른 자원을 기다리는 상태가 되어야 한다.
- **원형 대기**: 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다. 프로세스가 특정 자원에 대해 점유와 대기를 한다고 해서 모두 교착 상태에 빠지는 것은 아니다. 점유와 대기를 하는 프로세스들이 서로 방해하는 방향이 원을 이루면 프로세스들이 서로 양보하지 않기 때문에 교착 상태에 빠진다.

## 2. 식사하는 철학자 문제와 교착 상태 필요조건

중요한 점은 교착 상태와 아사 현상이 다르다는 것이다. 아사 현상은 정책상 잘못이나 오류로 인해 특정 프로세스의 작업이 이루어지지 않는 것을 말한다. 

교착 상태는 아사 현상과 달리 정책상 잘못이나 오류가 없어도 자연적으로 발생한다. 따라서 교착 상태는 에이징으로도 해결할 수 없고 정책을 바꾼다고 해서 막을 수도 없다.

# 3. 교착 상태 해결 방법
## 1. 교착 상태 해결 방법
교착 상태를 해결하는 방법은 예방<sup>prevention</sup>, 회피<sup>avoidance</sup>, 검출<sup>detection</sup>이며, 추가적으로 교착 상태가 발견된 후에 자원을 회복<sup>recovery</sup>하는 방법도 있다.

| 해결 방법 | 특징 |
| ------- | --- |
| 교착 상태 예방 | 교착 상태를 유발하는 네 가지 조건을 무력화한다. |
| 교착 상태 회피 | 교착 상태가 발생하지 않는 수준으로 자원을 할당한다. |
| 교착 상태 검출 | 자원 할당 그래프를 사용하여 교착 상태를 발견한다. |
| 교착 상태 회복 | 교착 상태를 검출한 후 해결한다. |

- **교착 상태 예방**  
교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식이다. 교착 상태는 상호 배제, 비선점, 점유와 대기, 원형 대기라는 네 가지 조건을 동시에 충족해야 발생하기 때문에 이 중 하나라도 막는다면 교착 상태가 발생하지 않는다. 그러나 이 방법은 실효성이 적어 잘 사용되지 않는다.
- **교착 상태 회피**  
자원 할당량을 조절하여 교착 상태를 해결하는 방식이다. 즉 자원을 할당하다가 교착 상태를 유발할 가능성이 있다고 판단되면 자원 할당을 중단하고 지켜보는 것이다. 그러나 자원을 얼마만큼 할당해야 교착 상태가 발생하지 않는다는 보장이 없기 때문에 실효성이 적다.
- **교착 상태 검출과 회복**  
교착 상태 검출은 어떤 제약을 가하지 않고 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식이다. 만약 교착 상태가 발생하면 교착 상태 회복 단계가 진행된다. 교착 상태를 검출한 후 이를 회복시키는 것은 결론적으로 교착 상태를 해결하는 현실적인 접근 방법이다.

## 2. 교착 상태 예방
교착 상태 예방은 교착 상태를 유발하는 네 가지 조건 중 하나라도 발생하지 않도록 막아 교착 상태를 처리하는 방법이다.

### 2.1 상호 배제 예방
시스템 내에 있는 상호 배타적인 모든 자원, 즉 독점적으로 사용할 수 있는 자원을 없애버리는 방법이다. 시스템 내의 모든 자원을 공유할 수 있다면 교착 상태가 발생하지 않는다.

그러나 현실적으로는 모든 자원을 공유할 수 없으며 상호 배제를 적용하여 보호해야 하는 자원이 있다. 상호 배제를 무력화하는 것은 사실상 어렵다.

### 2.2 비선점 예방
모든 자원을 빼앗을 수 있도록 만드는 방법이다. 임계구역을 보호하기 위해 잠금을 사용하면 자원을 빼앗을 수 없을 뿐만 아니라 상호 배제도 보장할 수 없다.

설사 어떤 자원을 빼앗을 수 있도록 할지라도 어떤 기준으로 빼앗을지, 빼앗은 시간 중 얼마나 사용할지 결정하기가 어렵다. 게다가 이러한 방법은 아사 현상을 일으킨다.

아사 현상은 에이징으로 해결할 수 있다고 설명했다. 아사 현상을 해결하기 위해 에이징을 사용하는 것도 힘들다. 따라서 비선점 조건을 무력화하기가 어렵다.

### 2.3 점유와 대기 예방

프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법이다. 다시 말해 '전부 할당하거나 아니면 아예 할당하지 않는<sup>all or nothing</sup>' 방식을 적용하는 것이다. 이를 위해 프로세스는 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납해야 한다.

앞서 살펴본 상호 배제 예방과 비선점 예방은 자원에 대한 제약을 풀어버리는 것이다. 그러나 임계구역으로 보호받는 자원에 대한 제약을 풀기는 어렵다. 점유와 대기 예방은 자원이 아닌 프로세스의 자원 사용 방식을 변화시켜 교착 상태를 처리한다는 점에서 의미가 있다.

한편 점유와 대기 예방은 다음과 같은 단점이 있다.

- **프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.**  
프로세스가 필요한 자원을 모두 확보한 후 실행했는데 추가로 필요한 자원이 생기면 이를 다시 확보하기가 어렵다.
- **자원의 활용성이 떨어진다.**  
프로세스가 앞으로 사용할 자원까지 미리 선점해버리기 때문에 그 자원을 필요로 하는 다른 프로세스의 작업이 진행되지 않는다. 당장 사용하지도 않을 자원을 미리 선점하여 자원 낭비가 심하다.
- **많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다.**  
자원을 많이 사용하는 프로세스는 자원을 적게 사용하는 프로세스보다 자원을 동시에 확보하기가 어렵다. 그러므로 많은 자원을 사용하는 프로세스의 작업이 지연되는 아사 현상이 발생한다.
- **결국 일괄 작업 방식으로 동작한다.**  
점유와 대기 예방을 실제로 구현하면 거의 모든 프로세스가 일괄 작업 방식으로 처리된다. 시스템 자원은 대부분의 프로세스가 필요로 하는 자원인데, 이러한 자원을 확보한 순서대로 실행하면 그 자원을 획득한 프로세스가 작업을 끝내야 다른 프로세스가 작업을 할 수 있다. 결국 모든 작업이 일괄 작업 방식으로 처리되어 시스템의 효율이 떨어진다.

### 2.4 원형 대기 예방
점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 막는 방법이다.

자원을 한 방향으로만 사용하도록 설정함으로써 원형 대기를 예방할 수 있다. 즉 모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원을 할당하는 것이다.

원형 대기 예방의 경우 프로세스들이 자원을 사용하려고 할 때 작은 번호의 자원을 할당받은 후 큰 번호의 자원을 할당받도록 한다. 이와 반대로 할당받을 수 없다. 이렇게 하면 모든 자원이 한쪽 방향으로만(작은 번호에서 큰 번호로만) 사용되기 때문에 원형 대기가 발생하지 않는다.

- **프로세스 작업 진행에 유연성이 떨어진다.**  
- **자원의 번호를 어떻게 부여할 것인지가 문제이다.**

### 2.5 교착 상태 예방 정리
지금까지 살펴본 교착 상태 예방은 교착 상태를 유발하는 네 가지 조건이 일어나지 않도록 제약을 가하는 방법이다. 그러나 자원을 보호하기 위해 상호 배제와 비선점을 예방하기 어려우며 점유와 대기, 원형 대기는 프로세스 작업 방식을 제한하고 자원을 낭비하기 때문에 사용할 수 없다.

## 3. 교착 상태 회피
### 3.1 교착 상태 회피의 개념
교착 상태 회피는 프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어주는 방법이다. 교착 상태가 발생하지 않는 범위 내에서만 자원을 할당하고, 교착 상태가 발생하는 범위에 있으면 프로세스를 대기시킨다.

교착 상태 회피는 할당되는 자원의 수를 조절하여 교착 상태를 피한다. 교착 상태 예방은 프로세스의 작업 방식을 제약하기 때문에 사용할 수 없었는데, 교착 상태 회피는 시스템의 운영 방식에 변경을 가하지 않기 때문에 교착 상태 예방보다 좀 더 유연하다.

교착 상태 회피는 자원의 총수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태<sup>safe state</sup>와 불안정 상태<sup>unsafe state</sup>로 나누고 시스템이 안정 상태를 유지하도록 자원을 할당한다.

### 3.2 은행원 알고리즘
교착 상태 회피를 구현하는 방법은 여러 가지인데 그중 하나는 에츠허르 데이크스트라가 제안한 은행원 알고리즘<sup>banker's algorithm</sup>이다. 은행이 대출을 해주는 방식, 즉 대출 금액이 대출 가능한 범위 내이면(안정 상태이면) 허용되지만 그렇지 않으면 거부되는 것과 유사하기 때문에 이렇게 불리게 되었다.

은행원 알고리즘은 최악의 경우를 기준으로 함으로써 문제 상황을 철저히 피하여 교착 상태를 막는다.

은행원 알고리즘에서 각 프로세스는 자신이 사용할 자원의 최대 수<sup>Max</sup>를 운영체제에 알려준다. 운영체제가 자원을 할당할 때 시스템의 상태를 파악하는 데 꼭 필요한 정보이기 때문이다.

각 프로세스에 할당된 자원의 수는 '할당 자원'에 표시된다. 각 프로세스마다 자신이 선언한 최대 자원에서 현재 할당된 자원의 수를 빼면 '기대 자원'이 된다. 또한 전체 자원에서 각 프로세스에 할당되고 남은 자원의 수가 '가용 자원'이다. 따라서 가용 자원은 전체 자원에서 모든 프로세스의 할당 자원을 뺀 값이다. 자원을 할당할 때의 기준은 다음과 같다.

- 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당한다. 가용 자원이 기대 자원보다 크다는 것은 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미이므로 안정 상태이다.
- 가용 자원이 어떤 기대 자원보다 크지 않으면 할당하지 않는다. 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없다는 의미이므로 불안정 상태이다.

| 변수 | 설명 |
| --- | --- |
| 전체 자원(Total) | 시스템 내 전체 자원의 수 |
| 가용 자원(Available) | 시스템 내 현재 사용할 수 있는 자원의 수(가용 자원=전체 자원-모든 프로세스의 할당 자원) |
| 최대 자원(Max) | 각 프로세스가 선언한 최대 자원의 수 |
| 할당 자원(Allocation) | 각 프로세스에 현재 할당된 자원의 수 |
| 기대 자원(Expect) | 각 프로세스가 앞으로 사용할 자원의 수(기대 자원=최대 자원-할당 자원) |

### 3.3 교착 상태 회피의 문제점
교착 상태 회피의 원칙은 교착 상태가 발생하지 않을 수준까지만 자원을 나누어주는 것이다. 하지만 여기에는 다음과 같은 문제가 있기 때문에 교착 상태 회피를 사용하지 않는다.

- **프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.**
- **시스템의 전체 자원 수가 고정적이어야 한다.**
- **자원이 낭비된다.**  
교착 상태 회피는 실제로 교착 상태가 발생하지 않는데도 발생할 것이라고 예상함으로써 프로세스에 자원을 할당하는 데 제약을 둔다.

## 4. 교착 상태 검출
### 4.1 교착 상태 검출의 개념
교착 상태 예방은 실제로 구현하기 어렵고, 교착 상태 회피는 구현할 수는 있지만 자원을 낭비하는 문제가 있다. 따라서 교착 상태 해결 방법 중 가장 현실적인 것은 바로 교착 상태 검출이다. 교착 상태 검출은 운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 계속 주시하는 방법이다. 만약 교착 상태가 발견되면 이를 해결하기 위해 교착 상태 회복 단계를 밟는다.

### 4.2 타임아웃을 이용한 교착 상태 검출
타임아웃을 이용한 교착 상태 검출은 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리하는 방법이다. 교착 상태가 자주 발생하지 않을 것이라는 가정하에 사용하는 것으로 특별한 알고리즘이 없어 쉽게 구현할 수 있다. 그런데 이 방법은 다음과 같은 문제가 있다.

- **엉뚱한 프로세스가 강제 종료될 수 있다.**  
타임아웃 시간 동안 작업이 진행되지 않는 모든 프로세스가 교착 상태 때문에 작업이 이루어지지 않은 것은 아니다. 타임아웃을 이용하면 교착 상태 외의 다른 이유로 작업이 진행되지 못하는 모든 프로세스가 강제 종료될 수 있다.
- **모든 시스템에 적용할 수 없다.**  
하나의 운영체제 내에서 동작하는 프로세스들은 그 상태를 운영체제가 감시하기 때문에 타임아웃 방법을 적용할 수 있다. 그러나 여러 군데에 데이터가 나뉘어 있는 분산 데이터베이스의 경우에는 타임아웃을 이용하는 방법을 적용하기가 어렵다. 분산 데이터베이스는 데이터가 여러 시스템에 나뉘어 있고 각 시스템이 네트워크로 연결되어 있다. 이러한 시스템에서는 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지, 네트워크 문제 때문인지, 단순히 처리가 늦어지는 것인지 정확히 알 수 없다. 그러므로 타임아웃 방법을 적용하여 교착 상태를 파악하기 어렵다.

위와 같으 문제에도 불구하고 타임아웃은 대부분의 데이터베이스와 운영체제에서 많이 선호한다. 타임아웃을 이용하는 방법을 '가벼운 교착 상태 검출'이라 부르고, 자원 할당 그래프를 이용하는 방법을 '무거운 교착 상태 검출'이라 부른다. 윈도우에서 '프로그램이 응답이 없어 종료합니다'라는 메시지를 본 적이 있을 텐데 이것이 타임아웃을 이용하는 방법의 대표적인 예이다.

데이터베이스의 교착 상태 처리는 운영체제보다 복잡하다. 데이터베이스에서는 특히 데이터의 일관성이 깨지면 안 된다. 데이터를 조작할 때는 반드시 잠금을 얻은 후 작업을 시작한다. 만약 여러 개의 잠금을 얻어 언어 작업을 하던 중 타임아웃으로 프로세스가 종료되면 일부 데이터에 문제가 발생할 수도 있다.

타임아웃으로 데이터의 일관성이 깨지는 문제를 해결하기 위해 데이터베이스에서는 체크포인트<sup>check point</sup>와 롤백<sup>roll back</sup>을 사용한다. 체크포인트는 작업을 하다가 문제가 발생하면 저장된 상태로 되돌아오기 위한 표시이다. 체크포인트를 설정하면 현재의 시스템 상태가 하드디스크에 저장되는데, 이렇게 저장된 데이터를 스냅숏<sup>snap shot</sup>이라고 한다. 롤백은 작업을 하다가 문제가 발생하여 과거의 체크포인트로 되돌아가는 것을 말한다. 롤백이 일어나면 저장된 스냅숏을 복원하여 시스템을 체크포인트 시점으로 되돌린다.

이러한 방식은 운영체제에도 적용된다. 윈도우에서 '특정 시점으로 복원'은 스냅숏과 롤백을 이용하여 운영체제를 복원시키는 작업이다.

### 4.3 자원 할당 그래프를 이용한 교착 상태 검출
교착 상태를 검출하는 또 다른 방법은 자원 할당 그래프를 이용하는 것이다. 자원 할당 그래프를 보면 시스템 내의 프로세스가 어떤 자원을 사용히고 있는지 혹은 기다리고 있는지를 알 수 있다.

자원 할당 그래프를 이용하여 교착 상태를 검출하는 방법은 프로세스의 작업 방식을 제한하지 않으면서 교착 상태를 정확하게 파악할 수 있다는 것이 장점이다. 그러나 자원 할당 그래프를 유지하고, 갱신하고, 사이클을 검사하는 추가 작업으로 인해 오버헤드가 발생하는 단점이 있다. 이러한 추가 작업을 줄이기 위해 자원이 할당될 때마다 사이클 검사를 하는 것이 아니라 일정 시간마다 하는 방법도 있다.

## 5. 교착 상태 회복
교착 상태가 검출되면 교착 상태를 푸는 후속 작업을 하는데 이를 교착 상태 회복이라고 한다. 교착 상태 회복 단계에서는 교착 상태를 유발한 프로세스를 강제로 종료한다. 프로세스를 강제로 종료하는 방법은 다음과 같이 두 가지가 있다.

- **교착 상태를 일으킨 모든 프로세스를 동시에 종료**  
교착 상태를 일으킨 모든 프로세스를 동시에 종료하는 방법이다. 그런데 이 방법은 종료된 프로세스들이 동시에 작업을 시작하면 다시 교착 상태를 일으킬 가능성이 크다. 그러므로 모든 프로세스를 강제로 종료한 후 다시 실행할 때는 순차적으로 실행해야 하며, 이때 어떤 프로세스를 먼저 실행할 것인지 기준이 필요하다.
- **교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료**  
교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료하면서 나머지 프로세스의 상태를 파악하는 방법이다. 프로세스를 종료할 때 어떤 프로세스부터 종료할 것인지 다음과 같은 기준이 필요하다.
    - 우선순위가 낮은 프로세스를 먼저 종료한다.
    - 우선순위가 같은 경우 작업 시간이 짧은 프로세스를 먼저 종료한다.
    - 위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 종료한다.

교착 상태 회복 단계에서는 관련 프로세스를 강제로 종료하는 일뿐 아니라 강제 종료된 프로세스가 실행되기 전에 시스템을 복구하는 일도 해야 한다. 시스템 복구는 명령어가 실행될 때마다 체크포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 식으로 한다. 그런데 이 방법은 작업량이 상당하여 시스템에 부하를 주므로 체크포인트를 무분별하게 사용하지 말고 선택적으로 사용해야 한다.