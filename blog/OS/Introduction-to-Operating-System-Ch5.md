# 쉽게 배우는 운영체제 Ch.5

## Table of Contents

1. [프로세스 간 통신](#1.-프로세스-간-통신)
2. [공유 자원과 임계구역](#2.-공유-자원과-임계구역)
3. [임계구역 해결 방법](#3.-임계구역-해결-방법)

## 1. 프로세스 간 통신
### 1. 프로세스 간 통신의 개념
프로세스는 시스템 내에서 독립적으로 실행되기도 하고 데이터를 주고받으며 협업하기도 한다. 프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신<sup>IPC</sup>에는 같은 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함된다.

- **프로세스 내부 데이터 통신**: 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신이다. 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고받는다.
- **프로세스 간 데이터 통신**: 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로, 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신한다.
- **네트워크를 이용한 데이터 통신**: 여러 컴퓨터가 네트워크로 연결되어 있을 때도 통신이 가능한데, 이 경우 프로세스는 소켓을 이용하여 데이터를 주고받는다. 이처럼 소켓을 이용하는 프로세스 간 통신을 네트워킹이라고 한다. 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저 호출도 여기에 해당한다.

프로세스 간 통신 방식은 단순하다. 즉 데이터를 주거나<sup>send</sup> 받는다<sup>recevie</sup>.

### 2. 프로세스 간 통신의 분류
#### 2.1 통신 방향에 따른 분류
함수 호출도 데이터를 주고받는다는 의미에서 통신이라고 생각할 수도 있지만, 함수는 하나의 프로세스 내에서 순차적으로 실행되기 때문에 통신이라고 부르지 않는다. 프로세스 간 통신은 동시에 실행되는 프로세스끼리 데이터를 주고받는 작업을 의미한다.

- **양방향 통신<sup>duplex communication</sup>**: 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조로, 일반적인 통신은 모두 양방향 통신이다. 프로세스 간 통신에서는 소켓 통신이 양방향 통신에 해당한다.
- **반양방향 통신<sup>half-duplex communication</sup>**: 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조이다. 반양방향 통신의 대표적인 예는 무전기이다.
- **단방향 통신<sup>simplex communication</sup>**: 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조이다. 프로세스 간 통신에서는 전역 변수와 파이프가 단방향 통신에 해당한다.

대부분의 통신은 양방향 통신이지만 전역 변수는 단방향 통신이다.

#### 2.2 통신 구현 방식에 다른 분류
전역 변수를 사용하는 통신 방식의 가장 큰 문제는 언제 데이터를 보낼지 데이터를 받는 쪽에서는 모른다는 것이다. 그러므로 데이터를 받는 쪽에서는 반복적으로 전역 변수의 값을 점검하는 수 밖에 없다. 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기<sup>busy waiting</sup>라고 한다.

바쁜 대기 문제를 해결하기 위해서는 데이터가 도착했음을 알려주는 동기화<sup>synchronization</sup>를 사용한다.

프로세스 간 통신은 동기화 기능이 있느냐 없느냐에 따라 대기가 있는 통신<sup>blocking communication</sup>과 대기가 없는 통신<sup>non-blocking communication</sup>으로 구분된다. 대기가 있는 통신은 동기화 통신<sup>synchronous communication</sup>, 대기가 없는 통신은 비동기화 통신<sup>asynchronous communication</sup>이라고도 한다.

- **대기가 있는 통신**: 동기화를 지원하는 통신 방식이다. 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
- **대기가 없는 통신**: 동기화를 지원하지 않는 통신 방식이다. 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다.

대기가 없는 통신은 통신 오버헤드는 적지만 바쁜 대기처럼 사용자가 직접 처리해야 하는 작업이 많다.

| 분류 방식 | 종류 | 예 |
| ------- | --- | - |
| 통신 방향에 따른 분류 | 양방향 통신 | 일반적 통신, 소켓 |
| 통신 방향에 따른 분류 | 반양방향 통신 | 무전기 |
| 통신 방향에 따른 분류 | 단방향 통신 | 전역 변수, 파일, 파이프 |
| 통신 구현 방식에 따른 분류 | 대기가 있는 통신(동기화 통신) | 파이프, 소켓 |
| 통신 구현 방식에 따른 분류 | 대기가 없는 통신(비동기화 통신) | 전역 변수, 파일 |

### 3. 프로세스 간 통신의 종류
프로세스 간 통신은 데이터를 주거나 받는 동작으로 이루어지며 이는 쓰기 연산과 읽기 연산으로 간소화할 수 있다. 다음은 전역 변수 GV를 이용하여 send는 쓰기 연산으로, receive는 읽기 연산으로 변경한 것으로 연산만 바뀌었을 뿐 의미는 같다.
```
send → write(GV, message)
receive → read(GV, message)
```

프로세스 간 통신에서 가장 중요한 것은 프로세스 동기화이다.

#### 3.1 전역 변수를 이용한 통신
전역 변수를 이용한 통신은 공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것이다. 데이터를 보내는 쪽에서는 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서는 전역 변수의 값을 읽는다. 전역 변수를 이용한 통신 방식은 주로 직접적으로 관련이 있는 프로세스간에 사용한다.

#### 3.2 파일을 이용한 통신
파일 입출력 코드는 크게 세 부분으로 구성되어 있다. 즉 파일을 열고<sup>open</sup>, 쓰기<sup>write</sup> 또는 읽기<sup>read</sup> 연산을 한 후, 파일을 닫는다<sup>close</sup>.

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd;
    char buf[5];

    fd = open("com.txt", O_RDWR); // init
    write(gd, "Test", 5); // 하드디스크에서 쓰기
    read(fd, buf, 5); // 하드디스크에서 읽기
    close(fd); 

    exit(0);
}
```

- **파일 열기**  
첫 부분인 `open()`은 일종의 준비 단계이다. `open()` 함수를 이용하여 사용하고자 하는 파일이 있는지, 또 그 파일이 있다면 쓰기 권한이 있는지도 확인한다. 정상적으로 파일을 사용할 수 있따면 `open()` 함수는 `fd`를 반환한다. 여기서 `fd`는 해당 파일에 접근할 수 있는 일종의 열쇠이다. 
어떤 파일에 쓰기나 읽기 연산을 하려면 먼저 `fd`를 얻어야 하며 작업이 다 끝나면 `fd`를 돌려주어야 한다. 어떤 파일에 접근할 수 있는 권한인 `fd`를 파일 기술자<sup>file descriptor</sup>라고 부른다.

- **읽기 또는 쓰기 연산**  
`fd`는 해당 파일에 대한 접근 구너한을 가지고 있다. 따라서 쓰기나 읽기 연산의 맨 앞에는 언제나 `fd`를 사용한다.

- **파일 닫기**  
`close` 함수를 이용하여 파일을 닫는다.

파일 입출력 코드를 프로세스 입장에서 살펴보자. 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장되고, 읽기를 요구하면 입출력 관리 프로세스로부터 데이터를 가져온다. 쓰기 연산은 하드디스크에 데이터를 전송하는 명령, 읽기 연산은 하드디스크로 데이터를 가져오는 명령이라고 할 수 있으므로 파일 입출력도 통신이다.

파일을 이용한 통신은 부모-자식 관계 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않는다. 그래서 프로세스가 알아서 동기화를 해야 하는데 주로 부모 프로세스가 `wait()` 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.

#### 3.3 파이프를 이용한 통신
프로세스 동기화 문제를 해결하는 방법으로 파이프가 있다. 파이프는 운영체제가 제공하는 동기화 통신 방식으로, 파일 입출력과 같이 `open()` 함수로 기술자를 얻고 작업을 한 후 `close()` 함수로 마무리한다. 파이프를 이용한 통신은 전역 변수를 이용한 통신과 마찬가지로 단방향 통신이다.

- **이름 없는 파이프<sup>anonymouse pipe</sup>**: 일반적으로 파이프라고 하면 이름 없는 파이프를 가리킨다. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스 간 통신에 사용된다.
- **이름 있는 파이프<sup>named pipe</sup>**: FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용된다.

#### 3.4 소켓을 이용한 통신
여러 컴퓨터에 있는 프로세스 간 통신은 네트워킹이라고 한다. 네트워킹 상황에서의 통신은 원격 프로시저 호출이나 소켓을 이용한다. 프로시저 호출이 한 컴퓨터에 있는 함수를 호출하는 것이라면, 원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것이다.  
일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현한다. 소켓을 매개로 한 쪽의 프로세스와 반대쪽의 프로세스를 연결하는 작업을 바인딩<sup>binding</sup>이라고 한다.  
소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜 대기를 하지 않아도 된다.

#### 3.5 정리
프로세스 간에 데이터를 주고받는 행위는 읽기와 쓰기 연산으로 단순화할 수 있다. 동기화를 지원하는 프로세스 간 통신에는 open()과 close() 함수가 사용된다. open()으로 키<sup>descriptor</sup>를 받아 작업을 시작하고, 자원을 다 사용하면 close()로 키를 반납한다. 이러한 open-read/write-close 구조는 파일, 파이프, 소켓에 동일하게 적용된다.

| 종류 | 운영체제 동기화 지원 | open()/close() 사용 |
| --- | --------------- | ------------------ |
| 전역 변수 | X (바쁜 대기) | X |
| 파일 | X (`wait()` 함수 이용) | O |
| 파이프 | O | O |
| 소켓 | O | O |

## 2. 공유 자원과 임계구역
### 1. 공유 자원의 접근
공유 자원<sup>shared resource</sup>은 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말한다. 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있따. 따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야 한다.

2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 '경쟁 조건<sup>race condition</sup>이 발생했다'고 한다.

### 2. 임계구역
공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 임계구역<sup>critical section</sup>이라고 한다. 임계구역이라는 의미의 영어 단어 critical section에서 'critical'은 '(앞으로의 상황에 영향을 미친다는 점에서) 대단히 중요한'이라는 뜻으로, 프로세스 실행 상황에서 공유할 수 없는 자원이 중요한 자원이다.

임계구역에서는 프로세스들이 동시에 작업하면 안 된다. 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야 하며 임계구역의 프로세스가 나와야 들어갈 수 있다.

### 3. 생산자-소비자 문제
임계구역과 관련된 전통적인 문제로 생산자-소비자 문제<sup>producer-consumer problem</sup>가 있다. 생산자-소비자 문제에서는 생산자 프로세스와 소비자 프로세스가 서로 독립적으로 작업을 한다. 생산자는 계속 물건을 생산해서 버퍼에 넣고[input(buf)] 소비자는 계속 버퍼에서 물건을 가져온다[output(buf)]. 버퍼는 작업을 계속하기 위해 원형 버퍼<sup>circular buffer</sup>를 사용한다. 또한 버퍼가 비어있는지 가득 찼는지 확인하기 위해 sum이라는 전역 변수를 사용하는데, sum에는 현재 버퍼에 있는 상품의 총수가 저장된다.

생산자와 소비자가 전역 변수에 접근하는 타이밍을 서로 맞추지 않으면(동시에 실행되면) 문제가 발생한다.

임계구역은 전역 변수를 사용할 때뿐 아니라 하드웨어 자원을 사용할 때도 적용되는 개념이다.

### 4. 임계구역 해결 조건
- **상호 배제<sup>mutual exclusion</sup>**  
한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다. 이것이 지켜지지 않으면 임계구역을 설정한 의미가 없다. 임계구역 내에는 한 번에 하나의 프로세스만 있어야 한다.
- **한정 대기<sup>bounded waiting</sup>**  
어떤 프로세스도 무한 대기<sup>infinite postpone</sup>하지 않아야 한다. 즉 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
- **진행의 융통성<sup>progress flexibility</sup>**  
한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 것을 의미한다.

## 3. 임계구역 해결 방법
임계구역 문제를 해결하는 단순한 방법은 잠금<sup>lock</sup>을 이용하는 것이다.

### 1. 기본 코드 소개
```c
#include <stdio.h>

typedef enum {false, true} boolean;
extern boolean lock = false;
extern int balance;

main() {
    while(lock==true);
    lock = true;
    balance = balance + 10 // 임계구역
    lock = false
}
```

### 2. 임계구역 해결 조건을 고려한 코드 설계
#### 2.1 상호 배제 문제

```c
boolean lock=false; // 전역변수
```

<table>
<tr>
<th>
프로세스 P1
</th>
<th>
프로세스 P2
</th>
</tr>
<tr>
<td>
<pre lang="c">
while(lock==true);
lock=true;
/*
임계구역
*/
lock=false;
</pre>
</td>

<td>
<pre lang="c">
while(lock==true);
lock=true;
/*
임계구역
*/
lock=false;
</pre>
</td>
</tr>
</table>

프로세스 P1이 임계구역에 진입하고 나서 P1에게 주어진 CPU 시간을 다 써서(타임아웃) 준비 상태로 옮겨진다. 문맥 교환이 발생하고 프로세스 P2가 실행 상태로 바뀐다. 이 때 프로세스 P1이 잠금을 걸지 않았기 때문에 프로세스 P2는 임계구역에 진입할 수 있는 문제가 발생한다.

잠금이 풀리기를 기다리려면 바쁜 대기를 한다는 것이다. 바로 `while(lock==true);`문 부분인데, 작업을 할 필요가 없는 시간에도 계속 무한 루프를 돌면서 시스템 자원을 낭비하게 된다.

#### 2.2 한정 대기 문제

```c
/* 공유 변수 */
boolean lock1=false;
boolean lock2=false;
```

<table>
<tr>
<th>
프로세스 P1
</th>
<th>
프로세스 P2
</th>
</tr>
<tr>
<td>
<pre lang="c">
lock1=true;
while(lock2==true);
/*
임계구역
*/
lock1=false;
</pre>
</td>

<td>
<pre lang="c">
lock2=true;
while(lock1==true);
/*
임계구역
*/
lock2=false;
</pre>
</td>
</tr>
</table>

상호 배제를 보장하지 못하는 코드의 문제를 보완하여 작성한 이 코드는 전역 변수로 lock1과 lock2를 사용하고 초깃값은 둘 다 false이다.

일단 잠금을 하고 다른 프로세스가 잠겼는지 확인하므로 두 프로세스의 상호 배제가 보장된다.

그러나 이 경우에도 무한 대기 현상이 일어난다. 프로세스가 lock을 잠구기 전에 타임아웃이 되면서 발생한다.

결국 프로세스 P1과 P2 둘 다 while 문을 빠져나오지 못하고 무한 루프에 빠져서 임계구역에 진입하지 못한다. 이는 한정 대기 조건을 보장하지 못하는 상황으로 교착 상태<sup>deadlock</sup>라고 한다. 교착 상태는 프로세스가 살아 있으나 작업이 진행되지 못하는 상태를 말한다.

한편 이 경우에는 확정성 문제도 있다. 프로세스가 늘어나면 검사해야 하는 lock의 개수도 늘어나 비효율적이다.

#### 2.3 진행의 융통성 문제

```c
/* 공유 변수 */
int lock=1;
```

<table>
<tr>
<th>
프로세스 P1
</th>
<th>
프로세스 P2
</th>
</tr>
<tr>
<td>
<pre lang="c">
while(lock==2);
/*
임계구역
*/
lock=2;
</pre>
</td>

<td>
<pre lang="c">
while(lock==1);
/*
임계구역
*/
lock=1;
</pre>
</td>
</tr>
</table>

잠금을 확인하는 문장이 하나이므로 상호 배제와 한정 대기를 보장한다. 그러나 서로 번갈아가면서 실행된다는 것이 문제이다. 한 프로ㅔ쓰가 두 번 연달아 임계구역에 진입하고 싶어도 그럴 수 없다. 프로세스의 우선순위에 상관없이 번갈아가며 임계구역에 진입한다. 이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화<sup>lockstep synchronization</sup>라고 한다.

#### 2.4 하드웨어적인 해결 방법

임계구역을 하드웨어적으로 해결하는 방법은 편리하지만 바쁜 대기를 사용하여 검사하기 때문에 자원 낭비가 있다.

### 3. 피터슨 알고리즘
```c
/* 공유 변수 */
boolean lock1=false;
boolean lock2=false;
int turn=1;
```

<table>
<tr>
<th>
프로세스 P1
</th>
<th>
프로세스 P2
</th>
</tr>
<tr>
<td>
<pre lang="c">
lock1=true;
turn=2;
while(lock2=true && true==2);
/*
임계구역
*/
lock1=false;
</pre>
</td>
<td>
<pre lang="c">
lock2=true;
turn=1;
while(lock1==true && turn==1);
/*
임계구역
*/
lock2=false;
</pre>
</td>
</tr>
</table>

피터슨 알고리즘은 임계구역 문제를 해결하기 위해 게리 피터슨<sup>Gary Peterson</sup>이 제안하는 것이다.

피터슨 알고리즘은 임계구역 해결의 세 가지 조건을 모두 만족하지만 2개의 프로세스만 사용 가능하다는 한계가 있다. 여러 프로세스가 하나의 임계구역을 사용하려면 공유 변수를 추가하는 코드를 변경해야 한다.

### 4. 데커 알고리즘
테오도뤼스 데커<sup>Theodorus Dekker</sup>가 제안한 데커 알고리즘도 임계구역 해결의 세 가지 조건을 모두 만족하는 알고리즘이다. 데커 알고리즘은 하드웨어의 도움 없이도 임계구역 문제를 해결할 수 있다는 것이 특징이다.
```c
/* 공유 변수 */
boolean lock1=false;
boolean lock2=false;
int turn=1;
```

<table>
<tr>
<th>
프로세스 P1
</th>
<th>
프로세스 P2
</th>
</tr>
<tr>
<td>
<pre lang="c">
lock1=true;
while(lock2==true) {
    if(turn==2) {
        lock1=fasle;
        while(turn==2);
        lock1=true;
    }
}
/*
임계구역
*/
turn=2;
lock1=false;
</pre>
</td>

<td>
<pre lang="c">
lock2=true;
while(lock1==true) {
    if(turn==1) {
        lock2=false;
        while(turn==1);
        lock2=true;
    }
}
/*
임계구역
*/
turn=1;
lock2=false;
</pre>
</td>
</tr>
</table>

### 5. 세마포어
앞에서 살펴본 임계구역 해결 알고리즘은 바쁜 대기를 사용하여 자원을 낭비하고 알고리즘도 너무 복잡하다. 이러한 단점을 해결하기 위해 에츠허르 데이크스트라<sup>Edsger Dijkstra</sup>는 세마포어<sup>semaphore</sup>라는 알고리즘을 제안했다.

세마포어는 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어간다. 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다.

세마포어는 사용 전에 초기 설정[Semaphore(n)]을 하는데, 이때 n은 공유 가능한 자원의 수를 나타낸다. 세마포어는 초기화가 끝난 후 임계구역에 들어가기 전에 사용 중이라고  표시하고[P()] 임계구역을 나올 때 비었다고 표시하는[V()] 간단한 방법으로 임계구역을 보호한다.

- **Semaphore(n)**: 전역 변수 RS를 n으로 초기화한다. RS에는 현재 사용 가능한 자원의 수가 저장된다.
- **P()**: 잠금을 수행하는 코드로, RS가 0보다 크면(사용 가능한 자원이 있으면) 1만큼 감소시키고 임계구역에 진입한다. 만약 RS가 0보다 작으면(사용 가능한 자원이 없으면) 0보다 커질 때까지 기다린다.
- **V()**: 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보낸다.

```
대기할 때는 block() 코드를 사용한다.
```

세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 임계구역에 진입한다. 따라서 바쁜 대기를 하는 프로세스가 없다. 그러나 세마포어의 P()나 V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다. 그러므로 P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다.

### 6. 모니터
세마포어는 피터슨 알고리즘이나 데커 알고리즘보다 단순하고 사용하기 편리하지만 문제가 없는 것은 아니다. 세마포어의 가장 큰 문제는 잘못된 사용으로 인해 임계구역이 보호받지 못한다는 것이다.

공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요 없이 자동으로 처리하면 된다. 이를 실제로 구현한 것이 모니터<sup>monitor</sup>이다. 모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시킨다.

시스템 호출과 같은 방법으로 모니터도 보호할 자원을 임계구역으로 숨기고 임계구역에서 작업할 수 있는 인터페이스만 제공하여 자원을 보호한다.

1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 P()나 V()를 사용하지 않고 모니터에 작업 요청을 한다.
2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려준다.

모니터는 임계구역 보호화 동기화를 위해 내부적으로 상태 변수<sup>condition variable</sup>을 사용한다. 상태 변수에는 wait()와 signal() 기능이 있다.

- **wait()**: 모니터 큐에서 자신의 차례가 올 때까지 기다린다. 세마포어의 P()에 해당한다.
- **signal()**: 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨준다. 세마포어의 V()에 해당한다.