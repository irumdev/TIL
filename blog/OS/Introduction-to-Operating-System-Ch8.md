# 쉽게 배우는 운영체제 Ch.8

## Table of Contents

1.  가상 메모리의 개요
2.  페이징 기법
3.  세그먼테이션 기법
4.  세그먼테이션-페이징 혼용 기법

## 1. 가상 메모리의 개요

가상 메모리virtual memory는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다.

### 1. 가상 메모리 시스템

#### 1.1 가상 메모리의 개념

메모리의 크기는 컴퓨터마다 다른데 운영체제가 물리 메모리의 크기에만 의존한다면 2GB의 메모리에서 동작하는 프로그램이 1GB의 메모리에서는 동작하지 않을 수 있다. 프로그래머 또한 메모리 크기에 맞는 응용 프로그램만 개발해야 하는데, 실제로 메모리 크기를 고려하여 프로그래밍하기란 매우 어렵다. 사용할 수 있는 배열의 개수가 한정되거나 특정 변수에 접근할 수 없다는 제약은 프로그래머에게 큰 장벽이다.

현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다는 것이다. 이러한 메모리 시스템을 가상 메모리라고 부른다. 가상 메모리는 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술이다. 프로세스는 운영체제가 어디에 있는지, 물리 메모리의 크기가 어느 정도인지 신경 쓰지 않고 메모리를 마음대로 사용할 수 있다.

#### 1.2 가상 메모리의 크기와 주소

가상 메모리 시스템의 모든 프로세스는 물리 메모리와 별개로 자신이 메모리의 어느 위치에 있는지 상관없이 0번지부터 시작하는 연속된 메모리 공간을 가진다. 논리 주소는 물리 메모리의 주소 공간에 비례하고, 가상 주소는 물리 메모리 공간이 아닌 가상의 주소 공간을 가진다는 것이다.

가상 메모리는 크게 프로세스가 바라보는 메모리 영역과 메모리 관리자가 바라보는 메모리 영역으로 나뉜다.

이론적으로 가상 메모리는 무한대의 크기이다. 그러나 실제로 가상 메모리의 최대 크기는 그 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정되며, CPU의 비트에 따라 결정된다. 32bit CPU의 경우 32bit로 표현할 수 있는 최댓값인 232-1(16진수로 FFFFFFFF), 즉 약 4GB가 메모리의 최대 크기이고, 가상 메모리의 최대 크기도 약 4GB이다.

32bit CPU의 최대 메모리 크기는 4GB이다. 이 시스템에서 각각 4GB 주소 공간을 차지하는 10개의 프로세스를 동시에 실행하려면 운영체제를 포함하여 적어도 40GB의 메모리가 필요하다. 이 경우 가상 메모리 시스템에서는 물리 메모리의 내용 중 일부를 하드디스크의 일부 공간, 즉 스왑 영역으로 옮긴다. 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로서 메모리의 일부이며, 가상 메모리의 구성 요소 중 하나이다. 메모리 관리자는 물리 메모리의 부족한 부분을 스왑 영역으로 보충한다. 즉 물리 메모리가 꽉 찼을 때 일부 프로세스를 스왑 영역으로 보내고(스왑아웃), 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져온다(스왑인).

가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데 이러한 작업을 동적 주소 변환Dynamic Address Translation, DAT이라고 한다. 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자의 데이터를 물리 메모리에 배치할 수 있다. 이 과정에서 메모리 관리자는 물리 메모리를 어떤 방법으로 나눌지, 사용자 프로세스를 어디에 배치할지, 부족한 물리 메모리를 어떻게 처리할지 등의 복잡한 문제를 처리한다.

#### 1.4 가상 메모리의 메모리 분할 방식

실제 메로리에 있는 물리 주소 0번지는 운영체제 영역이므로 일반 프로세스가 사용할 수 없다. 따라서 가상 메모리 시스템에서는 운영체제를 제외한 나머지 메모리 영역을 일정한 크기로 나누어 일반 프로세스에 할당한다. 가상 메모리 시스템에서 가변 분할 방식을 이용한 메모리 관리 기법은 세그먼테이션, 고정 분할 방식을 이용한 메모리 관리 기법은 페이징이라고 한다.

이 중 세그먼테이션 기법은 가변 분할 방식의 단점인 외부 단편화 등의 문제 때문에 잘 사용되지 않는다. 또한 페이징 기법은 페이지 관리에 어려움이 있다. 따라서 가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법을 주로 사용한다.

| 구분 | 가상 메모리 | 물리 메모리 |
| --- | --- | --- |
| 최대 메모리 크기 | CPU의 비트 값에 의존 | CPU의 비트 값에 의존 |
| 메모리 분할 방식 | 세그먼테이션 | 가변 분할 방식 |
| 메모리 분할 방식 | 페이징 | 고정 분할 방식 |
| 메모리 분할 방식 | 세그먼테이션-페이징 혼용 기법 |   |
| 주소 지정 방식 | 가상 주소 | 절대 주소, 상대 주소 |

### 2. 매핑 테이블의 필요성과 역할

가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치하며, 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리한다.

매핑 테이블은 물리 메모리가 세그먼테이션으로 분할된 경우뿐 아니라 페이징으로 분할된 경우에도 똑같은 방식으로 적용된다. 페이징 기법에서 사용하는 매핑 테이블은 페이지 매핑 테이블page mapping table 또는 페이지 테이블이라고 부르며, 세그먼테이션 기법에서 사용하는 매핑 테이블은 세그먼테이션 매핑 테이블sementation mapping table 또는 세그먼테이션 테이블이라고 부른다.

## 2. 페이징 기법

### 1. 페이징 기법의 구현

페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기로 나누어 사용한다. 가상 주소의 분할된 각 영역은 페이지라고 부르며 첫 번째 영역은 페이지 0, 두 번째 영역은 페이지 1과 같이 번호를 매겨 관리한다. 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임frame이라고 부른다. 프레임도 페이지와 마찬가지로 번호를 매겨 관리한다. 페이지와 프레임의 크기는 같다.

페이지와 프레임은 크기가 같기 때문에 페이지는 어떤 프레임에도 배치될 수 있다. 모든 페이지의 위치 정보, 즉 어떤 페이지가 어떤 프레임에 있는지에 대한 연결(매핑) 정보는 페이지 테이블에 담겨 있다.

페이지 테이블은 하나의 열column로 구성된다. 페이지 테이블에는 숫자만 있는 것이 아니다. 특정 페이지가 물리 메모리에 없을 때 페이지 테이블에 invalid라고 표시되어 있는데, 이는 해당 페이지가 스왑 영역에 있다는 의미이다.

### 2. 페이징 기법의 주소 변환

#### 2.1 주소 변환 과정

```
📚 페이지 테이블 그림은 책의 p.387을 참고
```

가상 주소를 물리 주소로 변환하는 과정을 살펴보자. 예를 들어 프로세스가 30번지의 내용을 읽으려고read 할 때의 주소 변환 과정은 다음과 같다.

1.  가상 주소 30번지가 어느 페이지에 있는지 찾는다. 30번지는 페이지 3의 0번째 위치에 있다.
2.  페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
3.  최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근한다. 이 주소가 가상 주소 30번지의 물리 주소이다.

이번에는 프로세스가 가상 주소 18번지에 어떤 값을 저장하려고write 할 때의 주소 변환 과정을 살펴보자.

1.  가상 주소 18번지가 어느 페이지에 있는지 찾는다. 18번지는 페이지 1의 8번째 위치에 있다.
2.  페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
3.  프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장한다.

#### 2.2 정형화된 주소 변환

지금까지 살펴본 주소 변환 과정을 정형화해보자. 페이징 기법에서는 가상 주소를 `VA=<P, D>`로 표현하는데, 여기서 VA는 가상 주소virtual address, P는 페이지page, D는 페이지의 처음 위치에서 해당 주소까지의 거리distance를 의미한다.

페이징 기법에서의 주소 변환은 가상 주소 `VA=<P, D>`를 물리 주소 `PA=<F, D>`로 변환하는 것이다. PA는 물리 메모리의 주소를 가리키는 용어로 물리 주소 또는 실제 주소라고 한다. `PA=<F, D>`에서 F는 프레임frame, D는 프레임의 처음 위치에서 해당 주소까지의 거리distance를 의미한다.

```
VA=<P, D> → PA=<F, D>
```

페이지 테이블을 이용하면 간단하게 가상 주소를 물리 주소로 변환할 수 있다. 페이지 테이블에서 페이지 번호를 찾아 해당 프레임 번호를 쫓아가면 된다. 페이지 테이블은 페이지 번호, 프레임 번호로 구성되며, 각각의 한 줄은 페이지 테이블 엔트리Page Table Entry, PTE라고 부른다.

#### 2.3 16bit CPU의 주소 변환 예

페이지 크기가 다양할 경우 가상 주소를 <P, D>로 변환하는 공식은 다음과 같다.

```
P=나눗셈(가상 주소/한 페이지의 크기)의 몫
D=나눗셈(가상 주소/한 페이지의 크기)의 나머지
```

### 3. 페이지 테이블 관리

페이지 테이블 관리가 복잡한 이유는 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문이다.

페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다. 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다. 한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.

각 프로세스가 메모리에 접근하려고 할 때 메모리 관리자는 페이지 테이블의 위치를 재빨리 파악할 필요가 있다. 그래서 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터Page Table Register, PTBR에 보관한다. 페이지 테이블 기준 레지스터는 각 프로세스의 프로세스 제어 블록에 저장되는 데이터로, 물리 메모리 내에 페이지 테이블의 시작 주소를 가지고 있다.

### 4. 페이지 테이블 매핑 방식

페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라진다.

-   **직접 매핑direct mapping**  
    페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식. 별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라고 부른다.
-   **연관 매핑associative mapping**  
    페이지 테이블 전체를 스왑 영역에서 관하는 방식. 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장장치의 스왑 영역에 저장하고 그중 일부만 물리 메모리에 가지고 있다.  
    주소 변환 시 직접 매핑은 원하는 프레임 번호를 한 번 에 바로 얻을 수 있지만 연관 매핑은 물리 메모리 내의 페이티 테이블을 다 검색해야 한다. 만약 이렇게 했는데도 원하는 프레임 번호를 얻지 못하면 스왑 영역에 있는 페이지 테이블을 검색한다.
-   **집합-연관 매핑set-associative mapping**  
    연관 매핑의 문제를 개선한 방식. 모든 페이티 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져온다는 것은 연관 매핑과 동일하다. 다만 연관 매핑에서는 물리 메모리에 있는 데이터가 무작위로 올라오기 때문에 원하는 프레임 번호를 얻기 위해서 모든 테이블을 검색해야 하는 문제가 있었다. 그러나 집합-연관 매핑에서는 페이티 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.  
    연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간이 단축된다.
-   **역매핑invert mapping**  
    앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하는 방식. 직접 매핑, 연관 매핑, 집합-연관 매핑에서는 페이지 번호를 기준으로 테이블을 구성하지만, 역매핑에서는 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다. 다시 말해 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시한다.  
    역매핑의 가장 큰 특징은 프로세스의 수와 상관없이 테이블이 하나만 존재한다는 것이다. 다른 방식에서는 프로세스마다 페이지 테이블을 만들지만 역매핑에서는 물리 메모리를 기준으로 프레임 테이블을 만들기 때문에 전체 시스템에서 테이블의 수가 단 1개이다. 따라서 테이블의 크기가 매우 작다는 것이 장점이다.  
    역매핑은 테이블의 크기가 작지만 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있다. 또한 모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느리다.

#### 4.1 직접 매핑

직접 매핑은 모든 페이지 테이블을 물리 메모리에 가지고 있는 가장 단순한 방식이다. 물리 메모리가 충분할 때 사용할 수 있으며, 모든 페이지를 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠르다.

직접 매핑에서는 페이지 테이블 전체가 물리 메모리에 저장되기 때문에 가상 주소 `VA=<P, D>`를 물리 주소 `PA=<F, D>`로 변환하려면 페이지 테이블의 P번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있다. 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터PTBR가 가지고 있으므로 물리 메모리상 페이지 테이블의 P번째 주소기 시작 주소PTBR로부터 P번째 위치에 존재한다.

#### 4.2 연관 매핑

연관 매핑은 전체 페이지 테이블을 스왑 영역에 두고 페이지 테이블의 일부를 물리 메모리에 가져오는 방식이다. 그러므로 물리 메모리에는 일부 페이지만 무작위로 저장되어 있고 그 일부분의 테이블을 변호나 색인 버퍼Translation Look-aside Buffer, TLB 또는 연관 레지스터associate register라고 부른다. 변환 색인 버퍼는 페이지 번호와 프레임 번호로 구성된 작은 크기의 테이블이다.

연관 매핑 방식에서는 물리 메모리의 일부 테이블만 가지고 있기 때문에 작동 방식도 캐시 시스템과 유사하다. 캐시 시스템에서 원하는 데이터가 캐시에 있는 경우는 캐시 히트, 없는 경우 캐시 미스라고 하는데 연관 매핑도 마찬가지이다. 연관 매핑에서는 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 찾아본다. 원하는 페이지 번호가 변환 색인 버퍼에 있는 경우는 TLB 히트TLB hit라고 하며, 곧바로 물리 주소로 변환된다. 원하는 페이지 번호가 변환 색인 버퍼에 없는 경우 TLB 미스TLB miss라고 하며, 스왑 영역에 저장된 직접 매핑 테이블을 사용하여 프레임 번호로 변환한다.

연관 매핑 방식은 전체 페이지 테이블을 물리 메모리에 보관하지 않아 메모리를 절약할 수 있다는 것이 장점이다. 그러나 TLB 미스가 빈번하게 발생할 경우 시스템의 성능이 떨어지는 단점도 있다. 또한 변환 색인 버퍼는 페이지 테이블의 일부를 무작위로 가지고 있기 때문에 모든 변환 색인 버퍼를 검색한 후에야 원하는 페이지가 메모리에 없다는 것을 알 수 있다. 즉 TLB 미스를 알게 되는 시점이 변환 색인 버퍼를 모두 검색하고 난 후이다. 따라서 TLB 미스가 발생하면 주소 변환이 느려진다.

#### 4.3 집합-연관 매핑

연관 매핑에서 모든 변환 색인 버퍼를 검색한 후에야 TLB 미스가 있다는 사실을 알게 됨으로써 전체 시스템의 성능이 떨어지는 단점을 개선한 것이 집합-연관 매핑 방식이다. 일반적으로 컴퓨터를 사용할 때 파일이 많으면 디렉터리를 사용하여 일정한 묶음으로 모아놓는다. 디렉터리 매핑directory mapping이라고도 하는 집합-연관 매핑은 관련 있는 테이블을 덩어리로 모아 놓은 형태이다.

집합-연관 매핑 방식에서는 페이지 테이블을 같은 크기의 여러 묶음으로 나누고, 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리한다. 전체 페이지 테이블은 연관 매핑과 마찬가지로 스왑 영역에 있으며, 일부 테이블은 묶음 단위로 메모리로 옮긴다. 따라서 이 방식에서는 해당 묶음이 현재 메모리에 있는지, 스왑 영역에 있는지를 표시하는 디렉터리 테이블을 새로 만든다. 디렉터리 테이블을 살펴보면 원하는 테이블 묶음이 어디에 있는지 알 수 있으므로 전체 테이블을 찾아보지 않아도 TLB 미스를 바로 알 수 있다.

집합-연관 매핑 방식에서는 페이지 테이블이 일정 크기의 묶음으로 나뉘기 때문에 가상 주소를 `VA=<P, D>`가 아니라 `VA=<P1, P2, D>`로 바꾸어 표시한다. 여기서 P1은 디렉터리 테이블에서의 위치 정보를 P2는 묶음 내에서의 위치 정보를 나타낸다. 집합-연관 매핑 방식에서는 직접 매핑 방식처럼 한 번에 물리 주소로 변환되는 것이 아니라 두 단계를 거쳐 물리 주소로 변환된다.

직접 매핑 방식과 마찬가지로 디렉터리 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있다. 프로세스가 특정 주소를 요구하면 `VA=<P1, P2, D>`로 변환되고, P1을 이용하여 디렉터리 테이블에서 주소를 찾는다. 만약 Iinvalid라고 표시되어 있으면 TLB 미스가 발생한 것이다. 반대로 원하는 테이블이 물리 메모리에 있으면 묶음 테이블의 시작 주소가 명시되어 있다.

집합-연관 매핑은 직접 매핑과 연관 매핑의 장점을 합한 방식으로, 크기가 큰 페이지 테이블을 같은 크기의 묶음음으로 나누어 관리함으로써 효율적이다. 연관 매핑의 경우 변환 색인 버퍼에 여러 테이블이 섞여 있기 때문에 주소 변환을 위해 변환 색인 버퍼의 모든 테이블을 검색해야 하지만, 집합-연관 매핑에서는 디렉터리 테이블을 이용하여 묶음 테이블의 위치를 바로 확인할 수 있어 시간 낭비가 발생하지 않는다. 또한 집합-연관 매핑은 직접 매핑과 달리 일부 페이지 테이블만 메모리에서 관리하여 물리 메모리를 낭비하지 않는다.

#### 4.4 역매핑

역매핑은 물리 메모리의 프레임 번호를 기준으로 테이블을 작성한다. 즉 물리 메모리가 어떤 프로세스의 어떤 페이지를 가지고 있는지를 테이블 형태로 구성한다.

역매핑 방식에서는 테이블이 <프레임 번호, 프로세스 아이디, 페이지 번호>로 구성되고, 페이지 테이블의 행 수는 실제 프로엠의 수와 같다. 그러므로 프로세스의 수와 상관없이 항상 일정 크기의 페이지 테이블을 유지하여 테이블의 크기가 매우 작다.

역매핑 방식에서 주소 변환 시 메모리 관리자는 주소 변환을 해야 하는 프로세스의 아이디와 페이지 번호가 물리 메모리에 있는지 역매핑 테이블에서 검색한다. 현재 테이블에 원하는 데이터가 없으면 스왑 영역에서 가져온다. 역매핑은 연관 매핑과 마찬가지로 페이지 테이블을 다 검사한 후에야 저장장치에 접근하기 때문에 검색 시간을 낭비하는 단점이 있다.

## 3. 세그먼테이션 기법

세그먼테이션 기법은 가변 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용한다.

### 1. 세그먼테이션 기법의 구현

페이징 기법과 마찬가지로 세그먼테이션 기법도 매핑 테이블을 사용하는데 이를 세그먼테이션 테이블segmentation tagble 또는 세그먼테이션 매핑 테이블segmentation mapping table이라고 한다.

세그먼테이션 테이블에는 세그먼트의 크기를 나타내는 limit와 물리 메모리 상의 시작 주소를 나타내는 address가 있다. 세그먼테이션 기법에서는 프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함한다. 각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안 되기 때문에 세그먼트의 크기 정보에는 크기를 뜻하는 size 대신 제한을 뜻하는 limit를 사용한다.

세그먼테이션 기법에서도 물리 메모리가 부족할 때 스왑 영역을 사용한다.

세그먼테이션 기법은 가변 분할 방식을 기본으로 하므로 가변 분할 방식의 장점과 단점을 모두 가지고 있다. 장점으로는 메모리를 프로세스 단위로 관리하기 때문에 페이지 테이블이 작고 단순하며, 단점은 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡하다.

### 2. 세그먼테이션 기법의 주소 변환

세그먼테이션 기법에서는 가상 주소를 `VA=<S, D>`로 표현한다. 여기서 S는 세그먼트 번호segment number, D는 세그먼트 시작 지점에서 해당 주소까지의 거리distance를 의미한다. 가상 메모리 시스템에서 사용자에게 보이는 메모리는 항상 0부터 시작하므로 페이징 기법이든 세그먼테이션 기법이든 D는 사용자가 지정한 주소 그 자체이다.

```
📚 세그먼테이션 테이블 그림은 책의 p.404을 참고
```

프로세스 A의 32번지에 접근할 때 주소 변환 과정은 다음과 같다.

1.  먼저 가상 주소를 구한다. 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0이고 D는 32이다. 따라서 가상 주소는 `VA=<0, 32>`이다.
2.  세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아낸 후 시작 주소 120에 거리 32를 더하여 물리 주소 152번지를 구한다. 이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검한다. 만약 크다면(메모리를 벗어나면) 메모리 오류를 출력하고 해당 프로세스를 강제 종료하며, 크지 않다면 물리 주소를 구한다.
3.  물리 주소 152번지에 접근하여 원하는 데이터를 읽거나 쓴다.

세그먼테이션 테이블의 limit는 메모리를 보호하는 역할을 한다. 만약 사용자가 사용하겠다고 선언한 프로세스 A의 크기보다 더 큰 주소에 접근하려고 하면 메모리 관리자는 해당 프로세스를 강제 종료하는데, 이때 발생하는 오류를 트랩trap이라고 한다. 트랩은 자신의 영역에 벗어나는 주소에 접근하거나 숫자를 0으로 나누는 것과 같이 사용자가 의도치 않게 일으키는 인터럽트를 말한다. 트랩이 발생하면 운영체제는 사용자에게 세그먼테이션 오류segmentation fault 메시지를 보낸다.

## 4. 세그먼테이션-페이징 혼용 기법

### 1. 메모리 접근 권한

메모리 접근 권한은 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 읽기read, 쓰기write, 실행execute, 추가append 권한이 있다. 이 네 가지 권한은 복합적으로 사용되는데, 예를 들면 일반적인 데이터에는 읽기 및 쓰기 권한이 적용되고, 상수나 읽기 전용 파일에는 읽기 권한이 적용된다. 또한 일반적인 코드 영역에는 읽기 및 실행 권한이 적용된다.

| 구분 | 읽기 | 쓰기 | 실행 | 비고 |
| --- | --- | --- | --- | --- |
| 모드 0 | x | x | x | 접근 불가 |
| 모드 1 | x | x | o | 실행만 가능 |
| 모드 2 | x | o | x | 실제로 사용하지 않음 |
| 모드 3 | x | o | o | 실제로 사용하지 않음 |
| 모드 4 | o | x | x | 읽기 전용 |
| 모드 5 | o | x | o | 읽고 실행 가능 |
| 모드 6 | o | o | x | 읽고 쓰기 가능 |
| 모드 7 | o | o | o | 제한 없음 |

프로세스는 몸체에 해당하는 코드 영역, 프로세스가 사용하는 데이터를 저장하는 데이터 영역, 프로세스를 실행하는 데 필요한 스택 영역과 프로세스 제어 블록PCB으로 구성된다.

코드 영역과 데이터의 접근 권한은 다음과 같다.

-   **코드 영역**: 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가진다.
-   **데이터 영역**: 데이터는 크게 읽거나 쓸 수 있는 데이터와 읽기만 가능한 데이터로 나눌 수 있다. 일반적인 변수는 읽거나 쓸 수 있으므로 읽기 및 쓰기 권한을 가지고 상수로 선언한 변수는 읽기 권한만 가진다.

메모리 접근 권한 검사는 가상 주소에서 물리 주소로 주소 변환이 일어날 때마다 시행된다. 만약 읽기만 가능한 메모리 영역에 쓰기를 하려고 하면 메모리 오류인 트랩이 발생한다. 페이징 기법이든 세그먼테이션 기법이든 매핑 테이블에 이러한 메모리 접근 권한에 대한 정보를 가지고 있으며, 주소 변환이 일어날 때마다 유용한 접근인지 아닌지 검사한다.

### 2. 세그먼테이션-페이징 혼용 기법의 도입

페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트right bit가 추가된다. 메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인한다.

페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 커진다. 이는 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정하여 메모리를 낭비하는 요소가 된다. 이러한 문제를 완화하려면 반복되는 권한 비트를 줄여야 한다.

권한 비트 추가에 따라 페이지 테이블 크기가 커지는 문제는 세그먼테이션 테이블을 이용하여 해결할 수 있다. 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리하고, 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다. 각 세그먼테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.

이와 같이 페이징 기법에 세그먼테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그먼테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있다. 이렇게 페이징 기법과 세그먼테이션 기법을 혼합하여 사용하면 순수 페이징 기법과 순수 세그먼테이션 기법의 장점만 취함으로써 메모리 관리를 효율적으로 할 수 있는데, 이를 세그먼테이션-페이징 혼용 기법이라고 한다. 현재 대부분의 운영체제는 이 방식을 사용하고 있다.

### 3. 세그먼테이션-페이징 혼용 기법의 주소 변환

세그먼테이션-페이징 혼용 기법에서는 가상 주소를 `VA=<S, P, D>`로 표현한다. 여기서 S는 세그먼트 번호, P는 페이지 번호, D는 페이지의 처음 위치에서 해당 주소까지의 거리를 의미한다. 이는 페이징 기법의 가상 주소 `VA=<P, D>`에 세그먼트 번호 S가 추가된 것이다.

세그먼테이션 페이징 혼용 기법에서 가상 주소를 물리 주소로 변환하는 과정은 다음과 같다.

1.  사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로부터 얼마나 떨어져 있는지 계산하여 가상 주소 `VA=<S, P, D>`를 구한다.
2.  세그먼테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인한다. 만약 권한이 없는 페이지에 접근하거나 자신에게 주어진 메모리 영역을 벗어나면 세그먼테이션 오류(트랩)를 발생시켜 프로세스를 강제 종료하고, 그렇지 않으면 연결된 페이지 테이블로 간다.
3.  페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 찾는다. 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근하고, 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져온다.
4.  물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다.