# 쉽게 배우는 운영체제 Ch.3

## Table of Contents

1. [프로세스의 개요](#1.-프로세스의-개요)
2. [프로세스 제어 블록과 문맥 교환](#2.-프로세스-제어-블록과-문맥-교환)
3. [프로세스의 연산](#3.-프로세스의-연산)
4. [스레드](#4.-스레드)
5. [용어 설명](#5.-용어-설명)

## 1. 프로세스의 개요
### 1. 프로세스의 개념

폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미이다. 프로그램은 저장장치에 저장되어 있는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다.

프로그램이란 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것이다. 반면에 프로세스는 '실행한다'라고 표현하는데, 이는 프로그램으로 작성된 작업 절차를 실제로 실행에 옮긴다는 의미이다. 따라서 누군가가 작성한 프로그램이 실행되면 프로세스가 된다.

### 3. 프로그램에서 프로세스로의 전환

프로세스는 컴퓨터 시스템의 작업 단위로 태스크<sup>task</sup>라고도 부른다. 

우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다. 그와 동시에 프로세스 제어 블록<sup>Process Control Block</sup>을 만든다. 프로세스 제어 블록에는 프로세스를 처리하는 데 필요한 다양한 정보가 들어 있다. 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다. 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미이다.

프로세스 제어 블록에 있는 다양한 정보 중 대표적인 세 가지는 다음과 같다.
- **프로세스 구분자<sup>Process IDentification, PID</sup>**: 메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 구분자가 필요함
- **메모리 관련 정보**: 프로세스의 메모리 위치 정보가 담겨 있으며, 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어 있음
- **각종 중간값**: 프로세스가 사용했던 중간값이 저장된다. 시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘겨준다. 프로세스 제어 블록에는 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장된다. 또한 작업의 중간값을 보관 중인 다른 레지스터도 같이 저장된다.이렇게 저장된 값은 작업을 계속 진행할 수 있게 해준다.

결론적으로 하나의 프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터와 각종 레지스터 같은 중간값을 관리해야 하며, 이러한 정보를 보관하는 데이터 구조가 프로세스 제어 블록이다. 프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어 블록이 생성되어야 한다.

프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다. 또한 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.

### 4. 프로세스의 상태

운영체제에서 여러 가지 이유로 프로세스 상태<sup>process status</sup>가 변화된다. 일괄 작업 시스템의 경우 프로세스가 생성된 후 CPU를 얻어 실행되고 작업을 마치면 종료된다. 따라서 일괄 작업 시스템의 프로세스 상태는 생성<sup>create</sup>, 실행<sup>run</sup>, 완료<sup>terminate</sup>이다.

시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문이다.

#### 4.1 프로세스의 네 가지 상태
- **생성 상태<sup>create status</sup>**: 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. 프로세스를 관리하는 데 필요한 프로세스 제어 블록이 생성됨
- **준비 상태<sup>ready status</sup>**: 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태. 
- **실행 상태<sup>running status</sup>**: 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 'execute status'라고 표현하기도 한다. 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다 갔다 한다.
- **완료 상태<sup>terminate status</sup>**: 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미

준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러<sup>CPU scheduler</sup>가 담당한다. CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달하여 작업이 이루어지게 한다. 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업을 디스패치<sup>dispatch</sup>라고 한다. CPU 스케줄러는 프로세스의 전 상태, 즉 생성, 준비, 실행, 완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.

CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데, 프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라고 부른다. 프로세스는 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는데 이를 타임아웃<sup>time out<sup>이라고 한다.

새로운 프로세스가 실행 상태로 들어오면 CPU는 일정 시간(타임 슬라이스)이 흐른 뒤 알려달라고 클록에 요청한다. 일정 시간이 다 되면 클록은 인터럽트를 사용하여 일정 시간이 흘렀다고 CPU에 알려준다.

#### 4.2 프로세스의 다섯 가지 상태

프로세스는 생성, 준비, 실행, 완료라는 네 가지 상태만으로 작업을 진행하는 데 큰 문제가 없다. 그러나 오늘날 운영체제의 효율성을 고려하여 한 가지 상태를 더 만들었다.

입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 대기 상태<sup>blocking status</sup>라고 한다. 이는 작업의 효율성을 높이기 위해 입출력을 요청한 프로세스를 실행 상태에 두지 않고 대기 상태로 옮기는 것이다.

#### 4.3 휴식 상태와 보류 상태

- **휴식 상태<sup>pause status</sup>**  
프로세스가 작업을 일시적으로 쉬고 있는 상태. 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작할<sup>resume</sup> 수 있다.
- **보류 상태<sup>suspend status</sup>**  
프로세스가 메모리에서 잠시 쫓겨난 상태로 휴식 상태와 차이가 있음. 보류 상태는 '일시 정지 상태'라고도 불린다. 프로세스는 다음과 같은 경우에 보류 상태가 된다.
    - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
    - 프로그램에 오류가 있어서 실행을 미루어야 할 때
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때  

    보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역<sup>swap area</sup>에 보관된다.  
    보류 상태는 대기 상태에서 옮겨진 보류 대기 상태<sup>block suspend status</sup>와 준비 상태에서 옮겨진 보류 준비 상태<sup>ready suspend status</sup>로 구분되며, 각 상태에서 재시작하면 원래의 활성 상태로 들어간다. 또한 보류 대기 상태에서 입출력이 완료되면 활성 상태가 아닌 보류 준비 상태로 옮겨 견다.

## 2. 프로세스 제어 블록과 문맥 교환

### 1. 프로세스 제어 블록
프로세스 제어 블록<sup>PCB</sup>은 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조로 TCB<sup>Task Control Block</sup>라고도 한다. 모든 프로세스는 고유의 프로세스 제어 블록을 가지며, 프로세스 제어 블록은 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기된다.

#### 1.1 프로세스 제어 블록의 구성

- **포인터**: 준비 상태나 대기 상태는 큐로 운영되는데, 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용
- **프로세스 상태**: 프로세스가 현재 어떤 상태에 있는지를 나타냄
- **프로세스 구분자**: 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
- **프로그램 카운터**: 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
- **프로세스 우선순위**: 프로세스의 중요도를 선별하기 위한 값, 높은 우선순위의 프로세스가 낮은 우선순위의 프로세스보다 먼저 실행되고 더 자주 실행된다.
- **각종 레지스터 정보**: 프로세스가 실행되는 중에 사용하던 레지스터의 값이 저장됨. 이전에 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관
- **메모리 관리 정보**: 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값, 세그먼테이션 테이블<sup>segmentation table<sup>, 페이지 테이블<sup>page table</sup> 등의 정보 보관
- **할당된 자원 정보**: 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
- **계정 정보**: 계정 번호, CPU 할당 시간, CPU 사용 시간 등
- **부모 프로세스 구분자와 자식 프로세스 구분자**: 부모 프로세스<sup>parent process</sup>를 가리키는 PPID<sup>Parent PID</sup>와 자식 프로세스<sup>child process</sup>를 가리키는 CPID<sup>Child PID</sup> 정보 저장

### 2. 문맥 교환

#### 2.1 문맥 교환의 의미
문맥 교환<sup>context switching</sup>은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 이때 두 프로세스 제어 블록의 내용이 변경된다. 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 반대로 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅한다. 이전 작업 상태가 되어야 다음 작업을 할 수 있기 때문이다. 이와 같이 두 프로세스의 프로세스 제어 블록을 교환하는 작업이 문맥 교환이다.

#### 2.2 문맥 교환의 절차
문맥 교환이 일어나는 경우는 매우 다양하다. 일반적으로 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생하고, 인터럽트가 걸렸을 때도 발생한다. 

## 3. 프로세스의 연산

### 1. 프로세스의 구조
프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성된다.

- **코드 영역<sup>code area</sup>**  
프로그램의 본문이 기술된 곳으로 텍스트 영역<sup>text area</sup>이라고도 한다.
- **데이터 영역<sup>data area</sup>**  
코드가 실행되면서 사용하는 변수<sup>variable</sup>나 파일 등의 각종 데이터를 모아놓은 곳이다. 데이터는 변하는 값이기 때문에 이곳의 내용은 기본적으로 읽기와 쓰기가 가능하다. 물론 상수<sup>constant</sup>로 선언된 변수는 읽기 전용이지만 대부분의 변수는 읽기와 쓰기가 가능하다.
- **스택 영역<sup>stack area</sup>**  
운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다. 예를 들어 프로세스 내에서 함수를 호출하면<sup>function call</sup> 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장한다. 스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않는다.

### 2. 프로세스의 생성과 복사

프로세스는 프로그램을 실행할 때 새로 생성된다. 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.

프로세스를 새로 생성하는 방법뿐만 아니라 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법도 있다.

#### 2.1 fork() 시스템 호출의 개념
fork() 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수이다. 커널에서 제공하는 이 함수는 프로세스를 복사하는 일종의 시스템 호출이다. fork() 시스템 호출을 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다.

컴퓨터를 사용하다 보면 fork() 시스템 호출을 자주 접하게 된다. 예를 들어 워드프로세서 프로그램으로 문서 작업을 하다가 새로운 워드프로세서 프로그램을 하나 더 실행하면 운영체제는 새로운 워드프로세서 프로그램을 실행하지 않고 fork() 시스템 호출을 사용하여 기존의 워드프로세서를 복사한다. 이렇게 복사하면 처음 워드프로세서 프로그램을 실행하는 속도보다 훨씬 빠르다.

프로세스를 복사할 때 기존의 프로세스는 부모 프로세스가 되고 새로 생긴 프로세스는 자식 프로세스가 되며, 두 프로세스는 부모-자식 관계로 연결된다.

#### 2.2 fork() 시스템 호출의 동작 과정
fork() 시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단, 프로세스 제어 블록의 내용 중 일부가 변경되는데 변경되는 부분은 다음과 같다.
- 프로세스 구분자<sup>PID</sup>가 바뀐다.
- 부모 프로세스와 자식 프로세스가 차지하고 있는 메모리의 위치가 다르므로 메모리 관련 정보가 바뀐다.
- 부모 프로세스 구분자<sup>PPID</sup>와 자식 프로세스 구분자<sup>CPID</sup>가 바뀐다.

#### 2.3 fork() 시스템 호출의 장점
- **프로세스의 생성 속도가 빠르다.**  
하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 자식 프로세스의 생성 속도가 빠르다.
- **추가 작업 없이 자원을 상속할 수 있다.**  
부모 프로세스가 사용하던 모든 자원을 추가 작없 없이 자식 프로세스에 상속할 수 있다.
- **시스템 관리를 효율적으로 할 수 있다.**  
부모 프로세스와 자식 프로세스가 자식 프로세스 구분자와 부모 프로세스 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있다. 정리를 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리된다.

### 3. 프로세스의 전환
#### 3.1 exec() 시스템 호출의 개념
exec() 시스템 호출은 기존의 프로세스를 새로운 프로세스로 전환하는 함수이다. 
- **fork()**: 새로운 프로세스를 복사하는 시스템 호출이다.
- **exec()**: 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출이다. exec() 시스템 호출을 하면 현재의 프로세스가 완전히 다른 프로세스로 전환된다.

exec() 시스템 호출을 사용하는 목적은 프로세스의 구조체를 재활용하기 위함이다. 새로운 프로세스를 만들려면 프로세스 제어 블록을 만들고 메모리의 자리를 확보하는 과정이 필요하다. 또한 프로세스를 종료한 후 사용한 메모리를 청소<sup>garbage collection</sup>하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 한다. 이때 exec() 시스템 호출을 사용하면 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다. 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.

#### 3.2 exec() 시스템 호출의 동작 과정
exec() 시스템 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿔버린다. 또한 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 프로세스 제어 블록의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항 등은 변하지 않지만 프로그램 카운터 레지스터 값을 비솟한 각종 레지스터와 사용한 파일 정보가 모두 리셋된다.

### 4. 프로세스의 계층 구조

#### 4.1 유닉스의 프로세스 계층 구조
유닉스에서 커널이 처음 메모리에 올라와 부팅이 되면 커널 관련 프로세스를 여러 개 만드는데, 그중 init 프로세스는 전체 프로세스의 출발점이 된다. 운영체제는 프로세스를 효율적으로 관리하기 위해 init 프로세스를 만든 다음 나머지 프로세스를 init 프로세스의 자식으로 만든다.

#### 4.2 프로세스 계층 구조의 장점
프로세스의 계층 구조는 동시에 여러 작업을 처리하고 종료된 프로세스의 자원을 회수하는데 유용하다.
- **여러 작업의 동시 처리**
- **용이한 자원 회수**  
프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기가 수월하다. 프로세스가 작업을 마쳐서 그 프로세스가 사용하던 자원을 회수<sup>garbage collection</sup>할 때 특히 편리하다. 

### 4.3 미아 프로세스
프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스를 미아 프로세스<sup>orphan process</sup> 또는 좀비 프로세스<sup>zombie process</sup>라고 한다. 컴퓨터에 미아 프로세스가 많아지면 자원이 낭비됨으로써 효율적인 운영에 방해가 된다. 따라서 운영체제는 반환되지 못한 자원을 회수하는 자원 회수를 주기적으로 해야 한다.

## 4. 스레드

### 1. 스레드의 개념
#### 1.1 스레드의 정의
운영체제 입장에서의 작업 단위는 프로세스이고 CPU 입장에서의 작업 단위는 스레드이다.

스레드<sup>thread</sup>는 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위이다.

> **작업의 크기**  
작업을 상대적인 크기순으로 나열하면 job > task > operation이고, 이를 프로세스와 스레드의 관계에 대입하면 처리(job) > 프로세스(task) > 스레드(operation)가 된다. 여러 개의 스레드가 모여 프로세스를 이루고 여러 개의 프로세스가 모여 처리가 되며, 여러 개의 프로세스를 모아서 한꺼번에 처리하는 방법을 일괄 작업<sup>batch job</sup>이라고 한다.

#### 1.2 프로세스와 스레드의 차이

프로세스끼리는 약하게 연결되어 있는 반면 스레드끼리는 강하게 연결되어 있다.

- **멀티태스크**  
서로 독립적이어서 영향을 받지 않음, 다른 한쪽이 비정상적으로 종료되어도 정상적으로 작동함. 서로 독립적인 프로세스는 데이터를 주고받을 때 프로세스 간 통신<sup>Inter Process Communication, IPC</sup>을 이용
- **멀티스레드**  
멀티스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출 등의 방법으로 스레드 간 통신을 한다.

#### 1.3 스레드 관련 용어
- **멀티스레드**  
프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
- **멀티태스킹**  
운영체제가 CPU에 작업을 줄 대 시간을 잘게 나누어 배분하는 기법. 이렇게 여러 스레드에 시간을 잘게 나누어주는 시스템을 시분할 시스템<sup>time-sharing system</sup>이라고 한다.
- **멀티프로세싱**  
CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경. 멀티프로세싱은 하나의 컴퓨터에 여러 개의 CPU 혹은 하나의 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것이다. 네트워크로 연결된 여러 컴퓨터에 스레드를 나누어 협업하는 분산 시스템도 멀티프로세싱이라고 부른다.
- **CPU 멀티스레드**  
한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

### 3. 멀티스레드의 장단점
#### 3.1 멀티스레드의 장점
- **응답성 향상**: 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
- **자원 공유**: 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행할 수 있다.
- **효율성 향상**: 여러 개의 프로세스를 생성하는 것과 달리 멀티스레드는 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
- **다중 CPU 지원**: 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다.

#### 3.2 멀티스레드의 단점
모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.

### 4. 멀티스레드 모델
- **커널 스레드<sup>kernel thread</sup>**: 커널이 직접 생성하고 관리하는 스레드
- **사용자 스레드<sup>user thread</sup>**: 라이브러리에 의해 구현된 일반적인 스레드

사용자 스레드가 커널 스레드를 사용하려면 시스템 호출로 커널 기능을 이용해야 한다. 이때 커널 스레드와 사용자 스레드의 대응 방식에 따라 다음과 같이 분류된다.

#### 4.1 사용자 레벨 스레드<sup>user-level thread</sup>
운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법으로 초기의 스레드 시스템에서 이용되었다. 이 스레드는 사용자 레벨에서 스레드를 구현하기 때문에 관련 라이브러리를 사용하여 구현하며, 라이브러리는 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해준다. 그러므로 커널 입장에서 이 스레드는 하나의 프로세스처럼 보인다.

사용자 레벨 스레드는 커널 입장에서는 일반 프로세스이지만 커널이 하는 일을 라이브러리가 대신 처리하여 여러 개의 스레드를 작동한다. 따라서 사용자 프로세스 내에 여러 개의 스레드가 존재하지만 커널의 스레드 하나와 연결되기 때문에 1 to N 모델이라고 부른다.

사용자 레벨 스레드는 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 처리하기 때문에 문맥 교환이 필요 없다.

사용자 레벨 스레드의 단점은 여러 개의 스레드가 하나의 커널 스레드와 연결되기 때문에 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 된다는 것이다. 커널 입장에서는 하나의 프로세스이므로 일부 스레드만 대기 상태로 보낼 수 없다.

또 다른 단점은 한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기 때문에 여러 개의 CPU를 동시에 사용할 수 없다는 것이다. 또한 보약에 취약하다. 커널 레벨에서는 공유 변수를 보호하는 장치가 있으나 이러한 서비스를 커널이 아닌 라이브러리에서 구현해야 하기 때문이다.

#### 4.2 커널 레벨 스레드<sup>kernel-level thread</sup>
커널이 멀티스레드를 지원하는 방식으로, 하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에 1 to 1 모델이라고 부른다. 커널 레벨 스레드는 독립적으로 스케줄링이 되므로 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속할 수 있다. 또한 커널이 제공하는 보호 기능과 같은 모든 기능을 사용할 수도 있다.

커널 레벨 스레드의 장점은 커널 레벨에서 모든 작업을 지원하기 때문에 멀티 CPU를 사용할 수 있고, 하나의 스레드가 대기 상태에 있어도 다른 스레드는 작업을 계속할 수 있다. 또한 커널의 기능을 사용하므로 보안에 강하고 안정적으로 작동한다. 하지만 문맥 교환을 할 때 오버에스 때문에 느리게 작동한다.

#### 4.3 멀티레벨 스레드<sup>multi-level thread</sup> 또는 하이브리드 스레드<sup>hybrid thread</sup>
사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식이므로 M to N 모델이라고 부른다. 멀티레벨 스레드는 사용자 레벨 스레드와 커널 레벨 스레드의 방식을 혼용하기 때문에 사용자 레벨 스레드와 커널 레벨 스레드의 장단점을 모두 가지고 있다. 사용자 레벨 스레드보다 유연하게 작업을 처리할 수 있지만 여전히 문맥 교환시 오버헤드가 있어 사용자 레벨 스레드만큼 빠르지 않다.

## 5. 용어 설명
- **코어 덤프<sup>core dump</sup>**  
오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료를 만나면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는 것